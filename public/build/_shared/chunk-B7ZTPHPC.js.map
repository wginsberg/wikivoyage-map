{
  "version": 3,
  "sources": ["../../../node_modules/react-router-dom/server.js", "../../../node_modules/@remix-run/react/dist/esm/index.js", "../../../node_modules/@remix-run/server-runtime/dist/esm/responses.js", "../../../node_modules/turbo-stream/dist/turbo-stream.mjs", "../../../node_modules/@remix-run/server-runtime/dist/esm/single-fetch.js", "../../../node_modules/@remix-run/react/dist/esm/browser.js", "../../../node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js", "../../../node_modules/@remix-run/react/dist/esm/components.js", "../../../node_modules/@remix-run/react/dist/esm/invariant.js", "../../../node_modules/@remix-run/react/dist/esm/links.js", "../../../node_modules/@remix-run/react/dist/esm/routeModules.js", "../../../node_modules/@remix-run/react/dist/esm/markup.js", "../../../node_modules/@remix-run/react/dist/esm/single-fetch.js", "../../../node_modules/@remix-run/react/dist/esm/data.js", "../../../node_modules/@remix-run/react/dist/esm/errorBoundaries.js", "../../../node_modules/@remix-run/react/dist/esm/errors.js", "../../../node_modules/@remix-run/react/dist/esm/routes.js", "../../../node_modules/@remix-run/react/dist/esm/fallback.js", "../../../node_modules/@remix-run/react/dist/esm/scroll-restoration.js", "../../../node_modules/@remix-run/react/dist/esm/server.js"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar React = require('react');\nvar router = require('@remix-run/router');\nvar reactRouter = require('react-router');\nvar reactRouterDom = require('react-router-dom');\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n/**\n * A `<Router>` that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\",\n  future\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = reactRouterDom.parsePath(locationProp);\n  }\n  let action = router.Action.Pop;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state || null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /*#__PURE__*/React__namespace.createElement(reactRouterDom.Router, {\n    basename: basename,\n    children: children,\n    location: location,\n    navigationType: action,\n    navigator: staticNavigator,\n    future: future,\n    static: true\n  });\n}\n/**\n * A Data Router that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouterProvider({\n  context,\n  router: router$1,\n  hydrate = true,\n  nonce\n}) {\n  !(router$1 && context) ? process.env.NODE_ENV !== \"production\" ? router.UNSAFE_invariant(false, \"You must provide `router` and `context` to <StaticRouterProvider>\") : router.UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = {\n    router: router$1,\n    navigator: getStatelessNavigator(),\n    static: true,\n    staticContext: context,\n    basename: context.basename || \"/\"\n  };\n  let fetchersContext = new Map();\n  let hydrateScript = \"\";\n  if (hydrate !== false) {\n    let data = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    };\n    // Use JSON.parse here instead of embedding a raw JS object here to speed\n    // up parsing on the client.  Dual-stringify is needed to ensure all quotes\n    // are properly escaped in the resulting string.  See:\n    //   https://v8.dev/blog/cost-of-javascript-2019#json\n    let json = htmlEscape(JSON.stringify(JSON.stringify(data)));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  let {\n    state\n  } = dataRouterContext.router;\n  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_FetchersContext.Provider, {\n    value: fetchersContext\n  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_ViewTransitionContext.Provider, {\n    value: {\n      isTransitioning: false\n    }\n  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.Router, {\n    basename: dataRouterContext.basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: dataRouterContext.navigator,\n    static: dataRouterContext.static,\n    future: {\n      v7_relativeSplatPath: router$1.future.v7_relativeSplatPath\n    }\n  }, /*#__PURE__*/React__namespace.createElement(DataRoutes, {\n    routes: router$1.routes,\n    future: router$1.future,\n    state: state\n  })))))), hydrateScript ? /*#__PURE__*/React__namespace.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: hydrateScript\n    }\n  }) : null);\n}\nfunction DataRoutes({\n  routes,\n  future,\n  state\n}) {\n  return reactRouter.UNSAFE_useRoutesImpl(routes, undefined, state, future);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in react-router-dom/index.tsx :)\n    if (router.isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      // Do not serialize stack traces from SSR for security reasons\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.\n        ...(val.name !== \"Error\" ? {\n          __subType: val.name\n        } : {})\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n    },\n    replace(to) {\n      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere ` + `in your app.`);\n    },\n    go(delta) {\n      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${delta})\\` somewhere in your app.`);\n    },\n    back() {\n      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);\n    },\n    forward() {\n      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);\n    }\n  };\n}\nfunction createStaticHandler(routes, opts) {\n  return router.createStaticHandler(routes, {\n    ...opts,\n    mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties\n  });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n  let manifest = {};\n  let dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(routes, reactRouter.UNSAFE_mapRouteProperties, undefined, manifest);\n  // Because our context matches may be from a framework-agnostic set of\n  // routes passed to createStaticHandler(), we update them here with our\n  // newly created/enhanced data routes\n  let matches = context.matches.map(match => {\n    let route = manifest[match.route.id] || match.route;\n    return {\n      ...match,\n      route\n    };\n  });\n  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get future() {\n      return {\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: opts.future?.v7_partialHydration === true,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: opts.future?.v7_relativeSplatPath === true,\n        unstable_skipActionErrorRevalidation: false\n      };\n    },\n    get state() {\n      return {\n        historyAction: router.Action.Pop,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: router.IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: new Map(),\n        blockers: new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return undefined;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return router.IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    getBlocker() {\n      return router.IDLE_BLOCKER;\n    },\n    deleteBlocker() {\n      throw msg(\"deleteBlocker\");\n    },\n    _internalFetchControllers: new Map(),\n    _internalActiveDeferreds: new Map(),\n    _internalSetRoutes() {\n      throw msg(\"_internalSetRoutes\");\n    }\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : reactRouterDom.createPath(to);\n}\nfunction encodeLocation(to) {\n  let href = typeof to === \"string\" ? to : reactRouterDom.createPath(to);\n  // Treating this as a full URL will strip any trailing spaces so we need to\n  // pre-encode them since they might be part of a matching splat param from\n  // an ancestor route\n  href = href.replace(/ $/, \"%20\");\n  let encoded = ABSOLUTE_URL_REGEX.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n  return {\n    pathname: encoded.pathname,\n    search: encoded.search,\n    hash: encoded.hash\n  };\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n  return str.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n\nexports.StaticRouter = StaticRouter;\nexports.StaticRouterProvider = StaticRouterProvider;\nexports.createStaticHandler = createStaticHandler;\nexports.createStaticRouter = createStaticRouter;\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nexport { Form, Navigate, NavigationType, Outlet, Route, Routes, createPath, createRoutesFromChildren, createRoutesFromElements, createSearchParams, generatePath, isRouteErrorResponse, matchPath, matchRoutes, parsePath, renderMatches, resolvePath, unstable_usePrompt, unstable_useViewTransitionState, useAsyncError, useAsyncValue, useBeforeUnload, useBlocker, useFetchers, useFormAction, useHref, useInRouterContext, useLinkClickHandler, useLocation, useMatch, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRoutes, useSearchParams, useSubmit } from 'react-router-dom';\nexport { defer, json, redirect, redirectDocument } from '@remix-run/server-runtime';\nexport { RemixBrowser } from './browser.js';\nexport { Await, Link, Links, LiveReload, Meta, NavLink, PrefetchPageLinks, Scripts, RemixContext as UNSAFE_RemixContext, useActionData, useFetcher, useLoaderData, useMatches, useRouteLoaderData } from './components.js';\nexport { ScrollRestoration } from './scroll-restoration.js';\nexport { RemixServer } from './server.js';\nexport { defineClientAction as unstable_defineClientAction, defineClientLoader as unstable_defineClientLoader } from './single-fetch.js';\n", "/**\n * @remix-run/server-runtime v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { json as json$1, defer as defer$1, redirect as redirect$1, redirectDocument as redirectDocument$1 } from '@remix-run/router';\nimport { serializeError } from './errors.js';\n\n// must be a type since this is a subtype of response\n// interfaces must conform to the types they extend\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n *\n * @see https://remix.run/utils/json\n */\nconst json = (data, init = {}) => {\n  return json$1(data, init);\n};\n\n/**\n * This is a shortcut for creating Remix deferred responses\n *\n * @see https://remix.run/utils/defer\n */\nconst defer = (data, init = {}) => {\n  return defer$1(data, init);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirect = (url, init = 302) => {\n  return redirect$1(url, init);\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirectDocument = (url, init = 302) => {\n  return redirectDocument$1(url, init);\n};\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(response) {\n  return isRedirectStatusCode(response.status);\n}\nfunction isTrackedPromise(value) {\n  return value != null && typeof value.then === \"function\" && value._tracked === true;\n}\n\n// TODO: Figure out why ReadableStream types are borked sooooooo badly\n// in this file. Probably related to our TS configurations and configs\n// bleeding into each other.\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nfunction createDeferredReadableStream(deferredData, signal, serverMode) {\n  let encoder = new TextEncoder();\n  let stream = new ReadableStream({\n    async start(controller) {\n      let criticalData = {};\n      let preresolvedKeys = [];\n      for (let [key, value] of Object.entries(deferredData.data)) {\n        if (isTrackedPromise(value)) {\n          criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`;\n          if (typeof value._data !== \"undefined\" || typeof value._error !== \"undefined\") {\n            preresolvedKeys.push(key);\n          }\n        } else {\n          criticalData[key] = value;\n        }\n      }\n\n      // Send the critical data\n      controller.enqueue(encoder.encode(JSON.stringify(criticalData) + \"\\n\\n\"));\n      for (let preresolvedKey of preresolvedKeys) {\n        enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);\n      }\n      let unsubscribe = deferredData.subscribe((aborted, settledKey) => {\n        if (settledKey) {\n          enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);\n        }\n      });\n      await deferredData.resolveData(signal);\n      unsubscribe();\n      controller.close();\n    }\n  });\n  return stream;\n}\nfunction enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {\n  if (\"_error\" in promise) {\n    controller.enqueue(encoder.encode(\"error:\" + JSON.stringify({\n      [settledKey]: promise._error instanceof Error ? serializeError(promise._error, serverMode) : promise._error\n    }) + \"\\n\\n\"));\n  } else {\n    controller.enqueue(encoder.encode(\"data:\" + JSON.stringify({\n      [settledKey]: promise._data ?? null\n    }) + \"\\n\\n\"));\n  }\n}\n\nexport { createDeferredReadableStream, defer, isDeferredData, isRedirectResponse, isRedirectStatusCode, isResponse, json, redirect, redirectDocument };\n", "// src/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred = class {\n  promise;\n  resolve;\n  reject;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n};\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, { stream: true });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n  });\n}\n\n// src/flatten.ts\nfunction flatten(input) {\n  const { indices } = this;\n  const existing = indices.get(input);\n  if (existing)\n    return [existing];\n  if (input === void 0)\n    return UNDEFINED;\n  if (input === null)\n    return NULL;\n  if (Number.isNaN(input))\n    return NAN;\n  if (input === Number.POSITIVE_INFINITY)\n    return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY)\n    return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0)\n    return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\nfunction stringify(input, index) {\n  const { deferred, plugins } = this;\n  const str = this.stringified;\n  const partsForObj = (obj) => Object.keys(obj).map((k) => `\"${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n  switch (typeof input) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      str[index] = JSON.stringify(input);\n      break;\n    case \"bigint\":\n      str[index] = `[\"${TYPE_BIGINT}\",\"${input}\"]`;\n      break;\n    case \"symbol\": {\n      const keyFor = Symbol.keyFor(input);\n      if (!keyFor)\n        throw new Error(\n          \"Cannot encode symbol unless created with Symbol.for()\"\n        );\n      str[index] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n      break;\n    }\n    case \"object\": {\n      if (!input) {\n        str[index] = `${NULL}`;\n        break;\n      }\n      const isArray = Array.isArray(input);\n      let pluginHandled = false;\n      if (!isArray && plugins) {\n        for (const plugin of plugins) {\n          const pluginResult = plugin(input);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        let result = isArray ? \"[\" : \"{\";\n        if (isArray) {\n          for (let i = 0; i < input.length; i++)\n            result += (i ? \",\" : \"\") + (i in input ? flatten.call(this, input[i]) : HOLE);\n          str[index] = `${result}]`;\n        } else if (input instanceof Date) {\n          str[index] = `[\"${TYPE_DATE}\",${input.getTime()}]`;\n        } else if (input instanceof URL) {\n          str[index] = `[\"${TYPE_URL}\",${JSON.stringify(input.href)}]`;\n        } else if (input instanceof RegExp) {\n          str[index] = `[\"${TYPE_REGEXP}\",${JSON.stringify(\n            input.source\n          )},${JSON.stringify(input.flags)}]`;\n        } else if (input instanceof Set) {\n          if (input.size > 0) {\n            str[index] = `[\"${TYPE_SET}\",${[...input].map((val) => flatten.call(this, val)).join(\",\")}]`;\n          } else {\n            str[index] = `[\"${TYPE_SET}\"]`;\n          }\n        } else if (input instanceof Map) {\n          if (input.size > 0) {\n            str[index] = `[\"${TYPE_MAP}\",${[...input].flatMap(([k, v]) => [\n              flatten.call(this, k),\n              flatten.call(this, v)\n            ]).join(\",\")}]`;\n          } else {\n            str[index] = `[\"${TYPE_MAP}\"]`;\n          }\n        } else if (input instanceof Promise) {\n          str[index] = `[\"${TYPE_PROMISE}\",${index}]`;\n          deferred[index] = input;\n        } else if (input instanceof Error) {\n          str[index] = `[\"${TYPE_ERROR}\",${JSON.stringify(input.message)}`;\n          if (input.name !== \"Error\") {\n            str[index] += `,${JSON.stringify(input.name)}`;\n          }\n          str[index] += \"]\";\n        } else if (Object.getPrototypeOf(input) === null) {\n          str[index] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input)}}]`;\n        } else if (isPlainObject(input)) {\n          str[index] = `{${partsForObj(input)}}`;\n        } else {\n          throw new Error(\"Cannot encode object with prototype\");\n        }\n      }\n      break;\n    }\n    default:\n      throw new Error(\"Cannot encode function or unexpected type\");\n  }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n}\n\n// src/unflatten.ts\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n  const { hydrated, values } = this;\n  if (typeof parsed === \"number\")\n    return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length)\n    throw new SyntaxError();\n  const startIndex = values.length;\n  values.push(...parsed);\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n  const { hydrated, values, deferred, plugins } = this;\n  switch (index) {\n    case UNDEFINED:\n      return;\n    case NULL:\n      return null;\n    case NAN:\n      return NaN;\n    case POSITIVE_INFINITY:\n      return Infinity;\n    case NEGATIVE_INFINITY:\n      return -Infinity;\n    case NEGATIVE_ZERO:\n      return -0;\n  }\n  if (hydrated[index])\n    return hydrated[index];\n  const value = values[index];\n  if (!value || typeof value !== \"object\")\n    return hydrated[index] = value;\n  if (Array.isArray(value)) {\n    if (typeof value[0] === \"string\") {\n      const [type, b, c] = value;\n      switch (type) {\n        case TYPE_DATE:\n          return hydrated[index] = new Date(b);\n        case TYPE_URL:\n          return hydrated[index] = new URL(b);\n        case TYPE_BIGINT:\n          return hydrated[index] = BigInt(b);\n        case TYPE_REGEXP:\n          return hydrated[index] = new RegExp(b, c);\n        case TYPE_SYMBOL:\n          return hydrated[index] = Symbol.for(b);\n        case TYPE_SET:\n          const set = /* @__PURE__ */ new Set();\n          hydrated[index] = set;\n          for (let i = 1; i < value.length; i++)\n            set.add(hydrate.call(this, value[i]));\n          return set;\n        case TYPE_MAP:\n          const map = /* @__PURE__ */ new Map();\n          hydrated[index] = map;\n          for (let i = 1; i < value.length; i += 2) {\n            map.set(\n              hydrate.call(this, value[i]),\n              hydrate.call(this, value[i + 1])\n            );\n          }\n          return map;\n        case TYPE_NULL_OBJECT:\n          const obj = /* @__PURE__ */ Object.create(null);\n          hydrated[index] = obj;\n          for (const key in b)\n            obj[hydrate.call(this, Number(key))] = hydrate.call(this, b[key]);\n          return obj;\n        case TYPE_PROMISE:\n          if (hydrated[b]) {\n            return hydrated[index] = hydrated[b];\n          } else {\n            const d = new Deferred();\n            deferred[b] = d;\n            return hydrated[index] = d.promise;\n          }\n        case TYPE_ERROR:\n          const [, message, errorType] = value;\n          let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n          hydrated[index] = error;\n          return error;\n        case TYPE_PREVIOUS_RESOLVED:\n          return hydrate.call(this, b);\n        default:\n          if (Array.isArray(plugins)) {\n            const args = value.slice(1).map((i) => hydrate.call(this, i));\n            for (const plugin of plugins) {\n              const result = plugin(value[0], ...args);\n              if (result)\n                return hydrated[index] = result.value;\n            }\n          }\n          throw new SyntaxError();\n      }\n    } else {\n      const array = [];\n      hydrated[index] = array;\n      for (let i = 0; i < value.length; i++) {\n        const n = value[i];\n        if (n !== HOLE)\n          array[i] = hydrate.call(this, n);\n      }\n      return array;\n    }\n  } else {\n    const object = {};\n    hydrated[index] = object;\n    for (const key in value) {\n      object[hydrate.call(this, Number(key))] = hydrate.call(\n        this,\n        value[key]\n      );\n    }\n    return object;\n  }\n}\n\n// src/turbo-stream.ts\nasync function decode(readable, options) {\n  const { plugins } = options ?? {};\n  const done = new Deferred();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n      done.reject(reason);\n    });\n  }\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n  let line;\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n  while (!read.done) {\n    if (!read.value)\n      continue;\n    const line = read.value;\n    switch (line[0]) {\n      case TYPE_PROMISE: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.resolve(value);\n        break;\n      }\n      case TYPE_ERROR: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.reject(value);\n        break;\n      }\n      default:\n        throw new SyntaxError();\n    }\n    read = await reader.read();\n  }\n}\nfunction encode(input, options) {\n  const { plugins, signal } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */ new Map(),\n    stringified: [],\n    plugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(\n          textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`)\n        );\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n      const seenPromises = /* @__PURE__ */ new WeakSet();\n      while (Object.keys(encoder.deferred).length > 0) {\n        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {\n          if (seenPromises.has(deferred))\n            continue;\n          seenPromises.add(\n            encoder.deferred[Number(deferredId)] = raceSignal(\n              deferred,\n              encoder.signal\n            ).then(\n              (resolved) => {\n                const id2 = flatten.call(encoder, resolved);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              },\n              (reason) => {\n                if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                  reason = new Error(\"An unknown error occurred\");\n                }\n                const id2 = flatten.call(encoder, reason);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              }\n            ).finally(() => {\n              delete encoder.deferred[Number(deferredId)];\n            })\n          );\n        }\n        await Promise.race(Object.values(encoder.deferred));\n      }\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n  });\n  return readable;\n}\nfunction raceSignal(promise, signal) {\n  if (!signal)\n    return promise;\n  if (signal.aborted)\n    return Promise.reject(signal.reason || new Error(\"Signal was aborted.\"));\n  const abort = new Promise((resolve, reject) => {\n    signal.addEventListener(\"abort\", (event) => {\n      reject(signal.reason || new Error(\"Signal was aborted.\"));\n    });\n    promise.then(resolve).catch(reject);\n  });\n  abort.catch(() => {\n  });\n  return Promise.race([abort, promise]);\n}\nexport {\n  decode,\n  encode\n};\n", "/**\n * @remix-run/server-runtime v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl, isRouteErrorResponse } from '@remix-run/router';\nimport { encode } from 'turbo-stream';\nimport { sanitizeError, sanitizeErrors } from './errors.js';\nimport { ServerMode } from './mode.js';\nimport { isResponse, isDeferredData, isRedirectStatusCode } from './responses.js';\n\nconst SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nconst ResponseStubActionSymbol = Symbol(\"ResponseStubAction\");\nfunction getSingleFetchDataStrategy(responseStubs, {\n  isActionDataRequest,\n  loadRouteIds\n} = {}) {\n  return async ({\n    request,\n    matches\n  }) => {\n    // Don't call loaders on action data requests\n    if (isActionDataRequest && request.method === \"GET\") {\n      return await Promise.all(matches.map(m => m.resolve(async () => ({\n        type: \"data\",\n        result: null\n      }))));\n    }\n    let results = await Promise.all(matches.map(async match => {\n      let responseStub;\n      if (request.method !== \"GET\") {\n        responseStub = responseStubs[ResponseStubActionSymbol];\n      } else {\n        responseStub = responseStubs[match.route.id];\n      }\n      let result = await match.resolve(async handler => {\n        // Cast `ResponseStubImpl -> ResponseStub` to hide the symbol in userland\n        let ctx = {\n          response: responseStub\n        };\n        // Only run opt-in loaders when fine-grained revalidation is enabled\n        let data = loadRouteIds && !loadRouteIds.includes(match.route.id) ? null : await handler(ctx);\n        return {\n          type: \"data\",\n          result: data\n        };\n      });\n\n      // Transfer raw Response status/headers to responseStubs\n      if (isResponse(result.result)) {\n        proxyResponseToResponseStub(result.result.status, result.result.headers, responseStub);\n      } else if (isDeferredData(result.result) && result.result.init) {\n        proxyResponseToResponseStub(result.result.init.status, new Headers(result.result.init.headers), responseStub);\n      }\n      return result;\n    }));\n    return results;\n  };\n}\nfunction getSingleFetchResourceRouteDataStrategy({\n  responseStubs\n}) {\n  return async ({\n    matches\n  }) => {\n    let results = await Promise.all(matches.map(async match => {\n      let responseStub = match.shouldLoad ? responseStubs[match.route.id] : null;\n      let result = await match.resolve(async handler => {\n        // Cast `ResponseStubImpl -> ResponseStub` to hide the symbol in userland\n        let ctx = {\n          response: responseStub\n        };\n        let data = await handler(ctx);\n        return {\n          type: \"data\",\n          result: data\n        };\n      });\n      return result;\n    }));\n    return results;\n  };\n}\nasync function singleFetchAction(serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...(request.body ? {\n        duplex: \"half\"\n      } : undefined)\n    });\n    let responseStubs = getResponseStubs();\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      unstable_dataStrategy: getSingleFetchDataStrategy(responseStubs, {\n        isActionDataRequest: true\n      })\n    });\n\n    // Unlike `handleDataRequest`, when singleFetch is enabled, query does\n    // let non-Response return values through\n    if (isResponse(result)) {\n      return {\n        result: getSingleFetchRedirect(result.status, result.headers),\n        headers: result.headers,\n        status: 200\n      };\n    }\n    let context = result;\n    let singleFetchResult;\n    let {\n      statusCode,\n      headers\n    } = mergeResponseStubs(context, responseStubs, {\n      isActionDataRequest: true\n    });\n    if (isRedirectStatusCode(statusCode) && headers.has(\"Location\")) {\n      return {\n        result: getSingleFetchRedirect(statusCode, headers),\n        headers,\n        status: 200 // Don't want the `fetch` call to follow the redirect\n      };\n    }\n\n    // Sanitize errors outside of development environments\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        if ((!isRouteErrorResponse(err) || err.error) && !isResponseStub(err)) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    if (context.errors) {\n      let error = Object.values(context.errors)[0];\n      singleFetchResult = {\n        error: isResponseStub(error) ? null : error\n      };\n    } else {\n      singleFetchResult = {\n        data: Object.values(context.actionData || {})[0]\n      };\n    }\n    return {\n      result: singleFetchResult,\n      headers,\n      status: statusCode\n    };\n  } catch (error) {\n    handleError(error);\n    // These should only be internal remix errors, no need to deal with responseStubs\n    return {\n      result: {\n        error\n      },\n      headers: new Headers(),\n      status: 500\n    };\n  }\n}\nasync function singleFetchLoaders(serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    var _URL$searchParams$get;\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let loadRouteIds = ((_URL$searchParams$get = new URL(request.url).searchParams.get(\"_routes\")) === null || _URL$searchParams$get === void 0 ? void 0 : _URL$searchParams$get.split(\",\")) || undefined;\n    let responseStubs = getResponseStubs();\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      unstable_dataStrategy: getSingleFetchDataStrategy(responseStubs, {\n        loadRouteIds\n      })\n    });\n    if (isResponse(result)) {\n      return {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers)\n        },\n        headers: result.headers,\n        status: 200 // Don't want the `fetch` call to follow the redirect\n      };\n    }\n    let context = result;\n    let {\n      statusCode,\n      headers\n    } = mergeResponseStubs(context, responseStubs);\n    if (isRedirectStatusCode(statusCode) && headers.has(\"Location\")) {\n      return {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(statusCode, headers)\n        },\n        headers,\n        status: 200 // Don't want the `fetch` call to follow the redirect\n      };\n    }\n\n    // Sanitize errors outside of development environments\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        if ((!isRouteErrorResponse(err) || err.error) && !isResponseStub(err)) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n\n    // Aggregate results based on the matches we intended to load since we get\n    // `null` values back in `context.loaderData` for routes we didn't load\n    let results = {};\n    let loadedMatches = loadRouteIds ? context.matches.filter(m => m.route.loader && loadRouteIds.includes(m.route.id)) : context.matches;\n    loadedMatches.forEach(m => {\n      var _context$loaderData, _context$errors;\n      let data = (_context$loaderData = context.loaderData) === null || _context$loaderData === void 0 ? void 0 : _context$loaderData[m.route.id];\n      let error = (_context$errors = context.errors) === null || _context$errors === void 0 ? void 0 : _context$errors[m.route.id];\n      if (error !== undefined) {\n        if (isResponseStub(error)) {\n          results[m.route.id] = {\n            error: null\n          };\n        } else {\n          results[m.route.id] = {\n            error\n          };\n        }\n      } else if (data !== undefined) {\n        results[m.route.id] = {\n          data\n        };\n      }\n    });\n    return {\n      result: results,\n      headers,\n      status: statusCode\n    };\n  } catch (error) {\n    handleError(error);\n    // These should only be internal remix errors, no need to deal with responseStubs\n    return {\n      result: {\n        root: {\n          error\n        }\n      },\n      headers: new Headers(),\n      status: 500\n    };\n  }\n}\nfunction isResponseStub(value) {\n  return value && typeof value === \"object\" && ResponseStubOperationsSymbol in value;\n}\nfunction getResponseStub(status) {\n  let headers = new Headers();\n  let operations = [];\n  let headersProxy = new Proxy(headers, {\n    get(target, prop, receiver) {\n      if (prop === \"set\" || prop === \"append\" || prop === \"delete\") {\n        return (name, value) => {\n          operations.push([prop, name, value]);\n          Reflect.apply(target[prop], target, [name, value]);\n        };\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n  return {\n    status,\n    headers: headersProxy,\n    [ResponseStubOperationsSymbol]: operations\n  };\n}\nfunction getResponseStubs() {\n  return new Proxy({}, {\n    get(responseStubCache, prop) {\n      let cached = responseStubCache[prop];\n      if (!cached) {\n        responseStubCache[prop] = cached = getResponseStub();\n      }\n      return cached;\n    }\n  });\n}\nfunction proxyResponseToResponseStub(status, headers, responseStub) {\n  if (status != null && responseStub.status == null) {\n    responseStub.status = status;\n  }\n  for (let [k, v] of headers) {\n    if (k.toLowerCase() !== \"set-cookie\") {\n      responseStub.headers.set(k, v);\n    }\n  }\n\n  // Unsure why this is complaining?  It's fine in VSCode but fails with tsc...\n  // @ts-ignore - ignoring instead of expecting because otherwise build fails locally\n  for (let v of headers.getSetCookie()) {\n    responseStub.headers.append(\"Set-Cookie\", v);\n  }\n}\nfunction mergeResponseStubs(context, responseStubs, {\n  isActionDataRequest\n} = {}) {\n  let statusCode = undefined;\n  let headers = new Headers();\n\n  // Action followed by top-down loaders\n  let actionStub = responseStubs[ResponseStubActionSymbol];\n  let stubs = [actionStub];\n\n  // Nothing to merge at the route level on action data requests\n  if (!isActionDataRequest) {\n    stubs.push(...context.matches.map(m => responseStubs[m.route.id]));\n  }\n  for (let stub of stubs) {\n    // Take the highest error/redirect, or the lowest success value - preferring\n    // action 200's over loader 200s\n    if (\n    // first status found on the way down\n    statusCode === undefined && stub.status ||\n    // deeper 2xx status found while not overriding the action status\n    statusCode !== undefined && statusCode < 300 && stub.status && statusCode !== (actionStub === null || actionStub === void 0 ? void 0 : actionStub.status)) {\n      statusCode = stub.status;\n    }\n\n    // Replay headers operations in order\n    let ops = stub[ResponseStubOperationsSymbol];\n    for (let [op, ...args] of ops) {\n      // @ts-expect-error\n      headers[op](...args);\n    }\n  }\n\n  // If no response stubs set it, use whatever we got back from the router\n  // context which handles internal ErrorResponse cases like 404/405's where\n  // we may never run a loader/action\n  if (statusCode === undefined) {\n    statusCode = context.statusCode;\n  }\n  if (statusCode === undefined) {\n    statusCode = 200;\n  }\n  return {\n    statusCode,\n    headers\n  };\n}\nfunction getSingleFetchRedirect(status, headers) {\n  return {\n    redirect: headers.get(\"Location\"),\n    status,\n    revalidate:\n    // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n    // detail of ?_data requests as our way to tell the front end to revalidate when\n    // we didn't have a response body to include that information in.\n    // With single fetch, we tell the front end via this revalidate boolean field.\n    // However, we're respecting it for now because it may be something folks have\n    // used in their own responses\n    // TODO(v3): Consider removing or making this official public API\n    headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\"),\n    reload: headers.has(\"X-Remix-Reload-Document\")\n  };\n}\n\n// Note: If you change this function please change the corresponding\n// decodeViaTurboStream function in server-runtime\nfunction encodeViaTurboStream(data, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  // How long are we willing to wait for all of the promises in `data` to resolve\n  // before timing out?  We default this to 50ms shorter than the default value for\n  // `ABORT_DELAY` in our built-in `entry.server.tsx` so that once we reject we\n  // have time to flush the rejections down through React's rendering stream before `\n  // we call abort() on that.  If the user provides their own it's up to them to\n  // decouple the aborting of the stream from the aborting of React's renderToPipeableStream\n  let timeoutId = setTimeout(() => controller.abort(new Error(\"Server Timeout\")), typeof streamTimeout === \"number\" ? streamTimeout : 4950);\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return encode(data, {\n    signal: controller.signal,\n    plugins: [value => {\n      // Even though we sanitized errors on context.errors prior to responding,\n      // we still need to handle this for any deferred data that rejects with an\n      // Error - as those will not be sanitized yet\n      if (value instanceof Error) {\n        let {\n          name,\n          message,\n          stack\n        } = serverMode === ServerMode.Production ? sanitizeError(value, serverMode) : value;\n        return [\"SanitizedError\", name, message, stack];\n      }\n      if (value instanceof UNSAFE_ErrorResponseImpl) {\n        let {\n          data,\n          status,\n          statusText\n        } = value;\n        return [\"ErrorResponse\", data, status, statusText];\n      }\n      if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n        return [\"SingleFetchRedirect\", value[SingleFetchRedirectSymbol]];\n      }\n    }]\n  });\n}\n\n// Backwards-compatible type for Remix v2 where json/defer still use the old types,\n// and only non-json/defer returns use the new types.  This allows for incremental\n// migration of loaders to return naked objects.  In the next major version,\n// json/defer will be removed so everything will use the new simplified typings.\n// prettier-ignore\n\nconst ResponseStubOperationsSymbol = Symbol(\"ResponseStubOperations\");\n\n/**\n * A stubbed response to let you set the status/headers of your response from\n * loader/action functions\n */\n\n// loader\n\nlet defineLoader = loader => loader;\n\n// action\n\nlet defineAction = action => action;\n\nexport { ResponseStubOperationsSymbol, SingleFetchRedirectSymbol, defineAction, defineLoader, encodeViaTurboStream, getResponseStubs, getSingleFetchDataStrategy, getSingleFetchRedirect, getSingleFetchResourceRouteDataStrategy, isResponseStub, mergeResponseStubs, singleFetchAction, singleFetchLoaders };\n", "// REMIX HMR BEGIN\nif (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {\n  console.warn('remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.');\n} else {\n  var prevRefreshReg = window.$RefreshReg$;\n  var prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    window.$RefreshRuntime$.register(type, \"\\\"node_modules/@remix-run/react/dist/esm/browser.js\\\"\" + id);\n  }\n  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\n  import.meta.hot = __hmr__.createHotContext(\n  //@ts-expect-error\n  \"node_modules/@remix-run/react/dist/esm/browser.js\");\n}\n// REMIX HMR END\n\n/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createRouter, createBrowserHistory } from '@remix-run/router';\nimport * as React from 'react';\nimport { UNSAFE_mapRouteProperties } from 'react-router';\nimport { matchRoutes, RouterProvider } from 'react-router-dom';\nimport { RemixContext } from './components.js';\nimport { RemixErrorBoundary } from './errorBoundaries.js';\nimport { deserializeErrors } from './errors.js';\nimport { createClientRoutesWithHMRRevalidationOptOut, createClientRoutes, shouldHydrateRouteLoader } from './routes.js';\nimport { decodeViaTurboStream, getSingleFetchDataStrategy } from './single-fetch.js';\nimport invariant from './invariant.js';\n\n/* eslint-disable prefer-let/prefer-let */\n\n/* eslint-enable prefer-let/prefer-let */\n\nlet stateDecodingPromise;\nlet router;\nlet routerInitialized = false;\nlet hmrAbortController;\nlet hmrRouterReadyResolve;\n// There's a race condition with HMR where the remix:manifest is signaled before\n// the router is assigned in the RemixBrowser component. This promise gates the\n// HMR handler until the router is ready\nlet hmrRouterReadyPromise = new Promise(resolve => {\n  // body of a promise is executed immediately, so this can be resolved outside\n  // of the promise body\n  hmrRouterReadyResolve = resolve;\n}).catch(() => {\n  // This is a noop catch handler to avoid unhandled promise rejection warnings\n  // in the console. The promise is never rejected.\n  return undefined;\n});\n\n// @ts-expect-error\nif (import.meta && import.meta.hot) {\n  // @ts-expect-error\n  import.meta.hot.accept(\"remix:manifest\", async ({\n    assetsManifest,\n    needsRevalidation\n  }) => {\n    let router = await hmrRouterReadyPromise;\n    // This should never happen, but just in case...\n    if (!router) {\n      console.error(\"Failed to accept HMR update because the router was not ready.\");\n      return;\n    }\n    let routeIds = [...new Set(router.state.matches.map(m => m.route.id).concat(Object.keys(window.__remixRouteModules)))];\n    if (hmrAbortController) {\n      hmrAbortController.abort();\n    }\n    hmrAbortController = new AbortController();\n    let signal = hmrAbortController.signal;\n\n    // Load new route modules that we've seen.\n    let newRouteModules = Object.assign({}, window.__remixRouteModules, Object.fromEntries((await Promise.all(routeIds.map(async id => {\n      var _assetsManifest$hmr, _window$__remixRouteM, _window$__remixRouteM2, _window$__remixRouteM3;\n      if (!assetsManifest.routes[id]) {\n        return null;\n      }\n      let imported = await import(assetsManifest.routes[id].module + `?t=${(_assetsManifest$hmr = assetsManifest.hmr) === null || _assetsManifest$hmr === void 0 ? void 0 : _assetsManifest$hmr.timestamp}`);\n      return [id, {\n        ...imported,\n        // react-refresh takes care of updating these in-place,\n        // if we don't preserve existing values we'll loose state.\n        default: imported.default ? ((_window$__remixRouteM = window.__remixRouteModules[id]) === null || _window$__remixRouteM === void 0 ? void 0 : _window$__remixRouteM.default) ?? imported.default : imported.default,\n        ErrorBoundary: imported.ErrorBoundary ? ((_window$__remixRouteM2 = window.__remixRouteModules[id]) === null || _window$__remixRouteM2 === void 0 ? void 0 : _window$__remixRouteM2.ErrorBoundary) ?? imported.ErrorBoundary : imported.ErrorBoundary,\n        HydrateFallback: imported.HydrateFallback ? ((_window$__remixRouteM3 = window.__remixRouteModules[id]) === null || _window$__remixRouteM3 === void 0 ? void 0 : _window$__remixRouteM3.HydrateFallback) ?? imported.HydrateFallback : imported.HydrateFallback\n      }];\n    }))).filter(Boolean)));\n    Object.assign(window.__remixRouteModules, newRouteModules);\n    // Create new routes\n    let routes = createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, assetsManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n    // This is temporary API and will be more granular before release\n    router._internalSetRoutes(routes);\n\n    // Wait for router to be idle before updating the manifest and route modules\n    // and triggering a react-refresh\n    let unsub = router.subscribe(state => {\n      if (state.revalidation === \"idle\") {\n        unsub();\n        // Abort if a new update comes in while we're waiting for the\n        // router to be idle.\n        if (signal.aborted) return;\n        // Ensure RouterProvider setState has flushed before re-rendering\n        setTimeout(() => {\n          Object.assign(window.__remixManifest, assetsManifest);\n          window.$RefreshRuntime$.performReactRefresh();\n        }, 1);\n      }\n    });\n    window.__remixRevalidation = (window.__remixRevalidation || 0) + 1;\n    router.revalidate();\n  });\n}\n\n/**\n * The entry point for a Remix app when it is rendered in the browser (in\n * `app/entry.client.js`). This component is used by React to hydrate the HTML\n * that was received from the server.\n */\nfunction RemixBrowser(_props) {\n  _s();\n  if (!router) {\n    // Hard reload if the path we tried to load is not the current path.\n    // This is usually the result of 2 rapid back/forward clicks from an\n    // external site into a Remix app, where we initially start the load for\n    // one URL and while the JS chunks are loading a second forward click moves\n    // us to a new URL.  Avoid comparing search params because of CDNs which\n    // can be configured to ignore certain params and only pathname is relevant\n    // towards determining the route matches.\n    let initialPathname = window.__remixContext.url;\n    let hydratedPathname = window.location.pathname;\n    if (initialPathname !== hydratedPathname && !window.__remixContext.isSpaMode) {\n      let errorMsg = `Initial URL (${initialPathname}) does not match URL at time of hydration ` + `(${hydratedPathname}), reloading page...`;\n      console.error(errorMsg);\n      window.location.reload();\n      // Get out of here so the reload can happen - don't create the router\n      // since it'll then kick off unnecessary route.lazy() loads\n      return /*#__PURE__*/React.createElement(React.Fragment, null);\n    }\n\n    // When single fetch is enabled, we need to suspend until the initial state\n    // snapshot is decoded into window.__remixContext.state\n    if (window.__remixContext.future.unstable_singleFetch) {\n      // Note: `stateDecodingPromise` is not coupled to `router` - we'll reach this\n      // code potentially many times waiting for our state to arrive, but we'll\n      // then only get past here and create the `router` one time\n      if (!stateDecodingPromise) {\n        let stream = window.__remixContext.stream;\n        invariant(stream, \"No stream found for single fetch decoding\");\n        window.__remixContext.stream = undefined;\n        stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n          window.__remixContext.state = value.value;\n          stateDecodingPromise.value = true;\n        }).catch(e => {\n          stateDecodingPromise.error = e;\n        });\n      }\n      if (stateDecodingPromise.error) {\n        throw stateDecodingPromise.error;\n      }\n      if (!stateDecodingPromise.value) {\n        throw stateDecodingPromise;\n      }\n    }\n    let routes = createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n    let hydrationData = undefined;\n    if (!window.__remixContext.isSpaMode) {\n      // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n      // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n      // render the fallback so we need the client to do the same for hydration.\n      // The server loader data has already been exposed to these route `clientLoader`'s\n      // in `createClientRoutes` above, so we need to clear out the version we pass to\n      // `createBrowserRouter` so it initializes and runs the client loaders.\n      hydrationData = {\n        ...window.__remixContext.state,\n        loaderData: {\n          ...window.__remixContext.state.loaderData\n        }\n      };\n      let initialMatches = matchRoutes(routes, window.location);\n      if (initialMatches) {\n        for (let match of initialMatches) {\n          let routeId = match.route.id;\n          let route = window.__remixRouteModules[routeId];\n          let manifestRoute = window.__remixManifest.routes[routeId];\n          // Clear out the loaderData to avoid rendering the route component when the\n          // route opted into clientLoader hydration and either:\n          // * gave us a HydrateFallback\n          // * or doesn't have a server loader and we have no data to render\n          if (route && shouldHydrateRouteLoader(manifestRoute, route, window.__remixContext.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            hydrationData.loaderData[routeId] = undefined;\n          } else if (manifestRoute && !manifestRoute.hasLoader) {\n            // Since every Remix route gets a `loader` on the client side to load\n            // the route JS module, we need to add a `null` value to `loaderData`\n            // for any routes that don't have server loaders so our partial\n            // hydration logic doesn't kick off the route module loaders during\n            // hydration\n            hydrationData.loaderData[routeId] = null;\n          }\n        }\n      }\n      if (hydrationData && hydrationData.errors) {\n        hydrationData.errors = deserializeErrors(hydrationData.errors);\n      }\n    }\n\n    // We don't use createBrowserRouter here because we need fine-grained control\n    // over initialization to support synchronous `clientLoader` flows.\n    router = createRouter({\n      routes,\n      history: createBrowserHistory(),\n      basename: window.__remixContext.basename,\n      future: {\n        v7_normalizeFormMethod: true,\n        v7_fetcherPersist: window.__remixContext.future.v3_fetcherPersist,\n        v7_partialHydration: true,\n        v7_prependBasename: true,\n        v7_relativeSplatPath: window.__remixContext.future.v3_relativeSplatPath,\n        // Single fetch enables this underlying behavior\n        unstable_skipActionErrorRevalidation: window.__remixContext.future.unstable_singleFetch === true\n      },\n      hydrationData,\n      mapRouteProperties: UNSAFE_mapRouteProperties,\n      unstable_dataStrategy: window.__remixContext.future.unstable_singleFetch ? getSingleFetchDataStrategy(window.__remixManifest, window.__remixRouteModules) : undefined\n    });\n\n    // We can call initialize() immediately if the router doesn't have any\n    // loaders to run on hydration\n    if (router.state.initialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n\n    // @ts-ignore\n    router.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;\n    window.__remixRouter = router;\n\n    // Notify that the router is ready for HMR\n    if (hmrRouterReadyResolve) {\n      hmrRouterReadyResolve(router);\n    }\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [criticalCss, setCriticalCss] = React.useState(process.env.NODE_ENV === \"development\" ? window.__remixContext.criticalCss : undefined);\n  if (process.env.NODE_ENV === \"development\") {\n    window.__remixClearCriticalCss = () => setCriticalCss(undefined);\n  }\n\n  // This is due to the short circuit return above when the pathname doesn't\n  // match and we force a hard reload.  This is an exceptional scenario in which\n  // we can't hydrate anyway.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [location, setLocation] = React.useState(router.state.location);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (!routerInitialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n  }, []);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    return router.subscribe(newState => {\n      if (newState.location !== location) {\n        setLocation(newState.location);\n      }\n    });\n  }, [location]);\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return /*#__PURE__*/(\n    // This fragment is important to ensure we match the <RemixServer> JSX\n    // structure so that useId values hydrate correctly\n    React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RemixContext.Provider, {\n      value: {\n        manifest: window.__remixManifest,\n        routeModules: window.__remixRouteModules,\n        future: window.__remixContext.future,\n        criticalCss,\n        isSpaMode: window.__remixContext.isSpaMode\n      }\n    }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n      location: location\n    }, /*#__PURE__*/React.createElement(RouterProvider, {\n      router: router,\n      fallbackElement: null,\n      future: {\n        v7_startTransition: true\n      }\n    }))), window.__remixContext.future.unstable_singleFetch ? /*#__PURE__*/React.createElement(React.Fragment, null) : null)\n  );\n}\n_s(RemixBrowser, \"2Jc0pK5iA8IBztJHvZ5F40Owts4=\");\n_c = RemixBrowser;\nexport { RemixBrowser };\nvar _c;\n$RefreshReg$(_c, \"RemixBrowser\");\n\nwindow.$RefreshReg$ = prevRefreshReg;\nwindow.$RefreshSig$ = prevRefreshSig;", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';\nimport * as React from 'react';\nimport { useHref, NavLink as NavLink$1, Link as Link$1, matchRoutes, useLocation, Await as Await$1, useNavigation, useAsyncError, useMatches as useMatches$1, useLoaderData as useLoaderData$1, useRouteLoaderData as useRouteLoaderData$1, useActionData as useActionData$1, useFetcher as useFetcher$1, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext } from 'react-router-dom';\nimport invariant from './invariant.js';\nimport { getKeyedLinksForMatches, isPageLinkDescriptor, getNewMatchesForLinks, getDataLinkHrefs, getModuleLinkHrefs, getKeyedPrefetchLinks } from './links.js';\nimport { escapeHtml, createHtml } from './markup.js';\nimport { addRevalidationParam, singleFetchUrl } from './single-fetch.js';\n\nfunction useDataRouterContext() {\n  let context = React.useContext(UNSAFE_DataRouterContext);\n  invariant(context, \"You must render this element inside a <DataRouterContext.Provider> element\");\n  return context;\n}\nfunction useDataRouterStateContext() {\n  let context = React.useContext(UNSAFE_DataRouterStateContext);\n  invariant(context, \"You must render this element inside a <DataRouterStateContext.Provider> element\");\n  return context;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// RemixContext\n\nconst RemixContext = /*#__PURE__*/React.createContext(undefined);\nRemixContext.displayName = \"Remix\";\nfunction useRemixContext() {\n  let context = React.useContext(RemixContext);\n  invariant(context, \"You must render this element inside a <Remix> element\");\n  return context;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Public API\n\n/**\n * Defines the prefetching behavior of the link:\n *\n * - \"none\": Never fetched\n * - \"intent\": Fetched when the user focuses or hovers the link\n * - \"render\": Fetched when the link is rendered\n * - \"viewport\": Fetched when the link is in the viewport\n */\n\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let [maybePrefetch, setMaybePrefetch] = React.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = React.useState(false);\n  let {\n    onFocus,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart\n  } = theirElementProps;\n  let ref = React.useRef(null);\n  React.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n    if (prefetch === \"viewport\") {\n      let callback = entries => {\n        entries.forEach(entry => {\n          setShouldPrefetch(entry.isIntersecting);\n        });\n      };\n      let observer = new IntersectionObserver(callback, {\n        threshold: 0.5\n      });\n      if (ref.current) observer.observe(ref.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [prefetch]);\n  let setIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(true);\n    }\n  };\n  let cancelIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(false);\n      setShouldPrefetch(false);\n    }\n  };\n  React.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  return [shouldPrefetch, ref, {\n    onFocus: composeEventHandlers(onFocus, setIntent),\n    onBlur: composeEventHandlers(onBlur, cancelIntent),\n    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n    onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n  }];\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n/**\n * A special kind of `<Link>` that knows whether it is \"active\".\n *\n * @see https://remix.run/components/nav-link\n */\nlet NavLink = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to);\n  let href = useHref(to);\n  let [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(NavLink$1, _extends({}, props, prefetchHandlers, {\n    ref: mergeRefs(forwardedRef, ref),\n    to: to\n  })), shouldPrefetch && !isAbsolute ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nNavLink.displayName = \"NavLink\";\n\n/**\n * This component renders an anchor tag and is the primary way the user will\n * navigate around your website.\n *\n * @see https://remix.run/components/link\n */\nlet Link = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to);\n  let href = useHref(to);\n  let [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Link$1, _extends({}, props, prefetchHandlers, {\n    ref: mergeRefs(forwardedRef, ref),\n    to: to\n  })), shouldPrefetch && !isAbsolute ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nLink.displayName = \"Link\";\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return event => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\n\n// Return the matches actively being displayed:\n// - In SPA Mode we only SSR/hydrate the root match, and include all matches\n//   after hydration. This lets the router handle initial match loads via lazy().\n// - When an error boundary is rendered, we slice off matches up to the\n//   boundary for <Links>/<Meta>\nfunction getActiveMatches(matches, errors, isSpaMode) {\n  if (isSpaMode && !isHydrated) {\n    return [matches[0]];\n  }\n  if (errors) {\n    let errorIdx = matches.findIndex(m => errors[m.route.id] !== undefined);\n    return matches.slice(0, errorIdx + 1);\n  }\n  return matches;\n}\n\n/**\n * Renders the `<link>` tags for the current routes.\n *\n * @see https://remix.run/components/links\n */\nfunction Links() {\n  let {\n    isSpaMode,\n    manifest,\n    routeModules,\n    criticalCss\n  } = useRemixContext();\n  let {\n    errors,\n    matches: routerMatches\n  } = useDataRouterStateContext();\n  let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let keyedLinks = React.useMemo(() => getKeyedLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, criticalCss ? /*#__PURE__*/React.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: criticalCss\n    }\n  }) : null, keyedLinks.map(({\n    key,\n    link\n  }) => isPageLinkDescriptor(link) ? /*#__PURE__*/React.createElement(PrefetchPageLinks, _extends({\n    key: key\n  }, link)) : /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: key\n  }, link))));\n}\n\n/**\n * This component renders all the `<link rel=\"prefetch\">` and\n * `<link rel=\"modulepreload\"/>` tags for all the assets (data, modules, css) of\n * a given page.\n *\n * @param props\n * @param props.page\n * @see https://remix.run/components/prefetch-page-links\n */\nfunction PrefetchPageLinks({\n  page,\n  ...dataLinkProps\n}) {\n  let {\n    router\n  } = useDataRouterContext();\n  let matches = React.useMemo(() => matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);\n  if (!matches) {\n    console.warn(`Tried to prefetch ${page} but no routes matched.`);\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(PrefetchPageLinksImpl, _extends({\n    page: page,\n    matches: matches\n  }, dataLinkProps));\n}\nfunction useKeyedPrefetchLinks(matches) {\n  let {\n    manifest,\n    routeModules\n  } = useRemixContext();\n  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React.useState([]);\n  React.useEffect(() => {\n    let interrupted = false;\n    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {\n      if (!interrupted) {\n        setKeyedPrefetchLinks(links);\n      }\n    });\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, manifest, routeModules]);\n  return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let {\n    future,\n    manifest,\n    routeModules\n  } = useRemixContext();\n  let {\n    matches\n  } = useDataRouterStateContext();\n  let newMatchesForData = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"data\"), [page, nextMatches, matches, manifest, location]);\n  let newMatchesForAssets = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"assets\"), [page, nextMatches, matches, manifest, location]);\n  let dataHrefs = React.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);\n  let moduleHrefs = React.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);\n\n  // needs to be a hook with async behavior because we need the modules, not\n  // just the manifest like the other links in here.\n  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n  let linksToRender = null;\n  if (!future.unstable_singleFetch) {\n    // Non-single-fetch prefetching\n    linksToRender = dataHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n      key: href,\n      rel: \"prefetch\",\n      as: \"fetch\",\n      href: href\n    }, linkProps)));\n  } else if (newMatchesForData.length > 0) {\n    // Single-fetch with routes that require data\n    let url = addRevalidationParam(manifest, routeModules, nextMatches.map(m => m.route), newMatchesForData.map(m => m.route), singleFetchUrl(page));\n    if (url.searchParams.get(\"_routes\") !== \"\") {\n      linksToRender = /*#__PURE__*/React.createElement(\"link\", _extends({\n        key: url.pathname + url.search,\n        rel: \"prefetch\",\n        as: \"fetch\",\n        href: url.pathname + url.search\n      }, linkProps));\n    }\n  } else ;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, linksToRender, moduleHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: href,\n    rel: \"modulepreload\",\n    href: href\n  }, linkProps))), keyedPrefetchLinks.map(({\n    key,\n    link\n  }) =>\n  /*#__PURE__*/\n  // these don't spread `linkProps` because they are full link descriptors\n  // already with their own props\n  React.createElement(\"link\", _extends({\n    key: key\n  }, link))));\n}\n\n/**\n * Renders HTML tags related to metadata for the current route.\n *\n * @see https://remix.run/components/meta\n */\nfunction Meta() {\n  let {\n    isSpaMode,\n    routeModules\n  } = useRemixContext();\n  let {\n    errors,\n    matches: routerMatches,\n    loaderData\n  } = useDataRouterStateContext();\n  let location = useLocation();\n  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let error = null;\n  if (errors) {\n    error = errors[_matches[_matches.length - 1].route.id];\n  }\n  let meta = [];\n  let leafMeta = null;\n  let matches = [];\n  for (let i = 0; i < _matches.length; i++) {\n    let _match = _matches[i];\n    let routeId = _match.route.id;\n    let data = loaderData[routeId];\n    let params = _match.params;\n    let routeModule = routeModules[routeId];\n    let routeMeta = [];\n    let match = {\n      id: routeId,\n      data,\n      meta: [],\n      params: _match.params,\n      pathname: _match.pathname,\n      handle: _match.route.handle,\n      error\n    };\n    matches[i] = match;\n    if (routeModule !== null && routeModule !== void 0 && routeModule.meta) {\n      routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data,\n        params,\n        location,\n        matches,\n        error\n      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;\n    } else if (leafMeta) {\n      // We only assign the route's meta to the nearest leaf if there is no meta\n      // export in the route. The meta function may return a falsy value which\n      // is effectively the same as an empty array.\n      routeMeta = [...leafMeta];\n    }\n    routeMeta = routeMeta || [];\n    if (!Array.isArray(routeMeta)) {\n      throw new Error(\"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must \" + \"return an array of meta objects.\" + \"\\n\\nTo reference the meta function API, see https://remix.run/route/meta\");\n    }\n    match.meta = routeMeta;\n    matches[i] = match;\n    meta = [...routeMeta];\n    leafMeta = meta;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, meta.flat().map(metaProps => {\n    if (!metaProps) {\n      return null;\n    }\n    if (\"tagName\" in metaProps) {\n      let {\n        tagName,\n        ...rest\n      } = metaProps;\n      if (!isValidMetaTag(tagName)) {\n        console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);\n        return null;\n      }\n      let Comp = tagName;\n      return /*#__PURE__*/React.createElement(Comp, _extends({\n        key: JSON.stringify(rest)\n      }, rest));\n    }\n    if (\"title\" in metaProps) {\n      return /*#__PURE__*/React.createElement(\"title\", {\n        key: \"title\"\n      }, String(metaProps.title));\n    }\n    if (\"charset\" in metaProps) {\n      metaProps.charSet ??= metaProps.charset;\n      delete metaProps.charset;\n    }\n    if (\"charSet\" in metaProps && metaProps.charSet != null) {\n      return typeof metaProps.charSet === \"string\" ? /*#__PURE__*/React.createElement(\"meta\", {\n        key: \"charSet\",\n        charSet: metaProps.charSet\n      }) : null;\n    }\n    if (\"script:ld+json\" in metaProps) {\n      try {\n        let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n        return /*#__PURE__*/React.createElement(\"script\", {\n          key: `script:ld+json:${json}`,\n          type: \"application/ld+json\",\n          dangerouslySetInnerHTML: {\n            __html: json\n          }\n        });\n      } catch (err) {\n        return null;\n      }\n    }\n    return /*#__PURE__*/React.createElement(\"meta\", _extends({\n      key: JSON.stringify(metaProps)\n    }, metaProps));\n  }));\n}\nfunction isValidMetaTag(tagName) {\n  return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nfunction Await(props) {\n  return /*#__PURE__*/React.createElement(Await$1, props);\n}\n\n/**\n * Tracks whether Remix has finished hydrating or not, so scripts can be skipped\n * during client-side updates.\n */\nlet isHydrated = false;\n/**\n * Renders the `<script>` tags needed for the initial render. Bundles for\n * additional routes are loaded later as needed.\n *\n * @param props Additional properties to add to each script tag that is rendered.\n * In addition to scripts, \\<link rel=\"modulepreload\"> tags receive the crossOrigin\n * property if provided.\n *\n * @see https://remix.run/components/scripts\n */\nfunction Scripts(props) {\n  let {\n    manifest,\n    serverHandoffString,\n    abortDelay,\n    serializeError,\n    isSpaMode,\n    future,\n    renderMeta\n  } = useRemixContext();\n  let {\n    router,\n    static: isStatic,\n    staticContext\n  } = useDataRouterContext();\n  let {\n    matches: routerMatches\n  } = useDataRouterStateContext();\n  let navigation = useNavigation();\n\n  // Let <RemixServer> know that we hydrated and we should render the single\n  // fetch streaming scripts\n  if (renderMeta) {\n    renderMeta.didRenderScripts = true;\n  }\n  let matches = getActiveMatches(routerMatches, null, isSpaMode);\n  React.useEffect(() => {\n    isHydrated = true;\n  }, []);\n  let serializePreResolvedErrorImp = (key, error) => {\n    let toSerialize;\n    if (serializeError && error instanceof Error) {\n      toSerialize = serializeError(error);\n    } else {\n      toSerialize = error;\n    }\n    return `${JSON.stringify(key)}:__remixContext.p(!1, ${escapeHtml(JSON.stringify(toSerialize))})`;\n  };\n  let serializePreresolvedDataImp = (routeId, key, data) => {\n    let serializedData;\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return serializePreResolvedErrorImp(key, error);\n    }\n    return `${JSON.stringify(key)}:__remixContext.p(${escapeHtml(serializedData)})`;\n  };\n  let serializeErrorImp = (routeId, key, error) => {\n    let toSerialize;\n    if (serializeError && error instanceof Error) {\n      toSerialize = serializeError(error);\n    } else {\n      toSerialize = error;\n    }\n    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, !1, ${escapeHtml(JSON.stringify(toSerialize))})`;\n  };\n  let serializeDataImp = (routeId, key, data) => {\n    let serializedData;\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return serializeErrorImp(routeId, key, error);\n    }\n    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, ${escapeHtml(serializedData)})`;\n  };\n  let deferredScripts = [];\n  let initialScripts = React.useMemo(() => {\n    var _manifest$hmr;\n    let streamScript = future.unstable_singleFetch ?\n    // prettier-ignore\n    \"window.__remixContext.stream = new ReadableStream({\" + \"start(controller){\" + \"window.__remixContext.streamController = controller;\" + \"}\" + \"}).pipeThrough(new TextEncoderStream());\" : \"\";\n    let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};${streamScript}` : \" \";\n\n    // When single fetch is enabled, deferred is handled by turbo-stream\n    let activeDeferreds = future.unstable_singleFetch ? undefined : staticContext === null || staticContext === void 0 ? void 0 : staticContext.activeDeferreds;\n\n    // This sets up the __remixContext with utility functions used by the\n    // deferred scripts.\n    // - __remixContext.p is a function that takes a resolved value or error and returns a promise.\n    //   This is used for transmitting pre-resolved promises from the server to the client.\n    // - __remixContext.n is a function that takes a routeID and key to returns a promise for later\n    //   resolution by the subsequently streamed chunks.\n    // - __remixContext.r is a function that takes a routeID, key and value or error and resolves\n    //   the promise created by __remixContext.n.\n    // - __remixContext.t is a map or routeId to keys to an object containing `e` and `r` methods\n    //   to resolve or reject the promise created by __remixContext.n.\n    // - __remixContext.a is the active number of deferred scripts that should be rendered to match\n    //   the SSR tree for hydration on the client.\n    contextScript += !activeDeferreds ? \"\" : [\"__remixContext.p = function(v,e,p,x) {\", \"  if (typeof e !== 'undefined') {\", process.env.NODE_ENV === \"development\" ? \"    x=new Error(e.message);\\n    x.stack=e.stack;\" : '    x=new Error(\"Unexpected Server Error\");\\n    x.stack=undefined;', \"    p=Promise.reject(x);\", \"  } else {\", \"    p=Promise.resolve(v);\", \"  }\", \"  return p;\", \"};\", \"__remixContext.n = function(i,k) {\", \"  __remixContext.t = __remixContext.t || {};\", \"  __remixContext.t[i] = __remixContext.t[i] || {};\", \"  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});\", typeof abortDelay === \"number\" ? `setTimeout(() => {if(typeof p._error !== \"undefined\" || typeof p._data !== \"undefined\"){return;} __remixContext.t[i][k].e(new Error(\"Server timeout.\"))}, ${abortDelay});` : \"\", \"  return p;\", \"};\", \"__remixContext.r = function(i,k,v,e,p,x) {\", \"  p = __remixContext.t[i][k];\", \"  if (typeof e !== 'undefined') {\", process.env.NODE_ENV === \"development\" ? \"    x=new Error(e.message);\\n    x.stack=e.stack;\" : '    x=new Error(\"Unexpected Server Error\");\\n    x.stack=undefined;', \"    p.e(x);\", \"  } else {\", \"    p.r(v);\", \"  }\", \"};\"].join(\"\\n\") + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {\n      let pendingKeys = new Set(deferredData.pendingKeys);\n      let promiseKeyValues = deferredData.deferredKeys.map(key => {\n        if (pendingKeys.has(key)) {\n          deferredScripts.push( /*#__PURE__*/React.createElement(DeferredHydrationScript, {\n            key: `${routeId} | ${key}`,\n            deferredData: deferredData,\n            routeId: routeId,\n            dataKey: key,\n            scriptProps: props,\n            serializeData: serializeDataImp,\n            serializeError: serializeErrorImp\n          }));\n          return `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;\n        } else {\n          let trackedPromise = deferredData.data[key];\n          if (typeof trackedPromise._error !== \"undefined\") {\n            return serializePreResolvedErrorImp(key, trackedPromise._error);\n          } else {\n            return serializePreresolvedDataImp(routeId, key, trackedPromise._data);\n          }\n        }\n      }).join(\",\\n\");\n      return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;\n    }).join(\"\\n\") + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : \"\");\n    let routeModulesScript = !isStatic ? \" \" : `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}import ${JSON.stringify(manifest.url)};\n${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(\"\\n\")}\nwindow.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(contextScript),\n      type: undefined\n    })), /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(routeModulesScript),\n      type: \"module\",\n      async: true\n    })));\n    // disabled deps array because we are purposefully only rendering this once\n    // for hydration, after that we want to just continue rendering the initial\n    // scripts as they were when the page first loaded\n    // eslint-disable-next-line\n  }, []);\n  if (!isStatic && typeof __remixContext === \"object\" && __remixContext.a) {\n    for (let i = 0; i < __remixContext.a; i++) {\n      deferredScripts.push( /*#__PURE__*/React.createElement(DeferredHydrationScript, {\n        key: i,\n        scriptProps: props,\n        serializeData: serializeDataImp,\n        serializeError: serializeErrorImp\n      }));\n    }\n  }\n\n  // avoid waterfall when importing the next route module\n  let nextMatches = React.useMemo(() => {\n    if (navigation.location) {\n      // FIXME: can probably use transitionManager `nextMatches`\n      let matches = matchRoutes(router.routes, navigation.location, router.basename);\n      invariant(matches, `No routes match path \"${navigation.location.pathname}\"`);\n      return matches;\n    }\n    return [];\n  }, [navigation.location, router.routes, router.basename]);\n  let routePreloads = matches.concat(nextMatches).map(match => {\n    let route = manifest.routes[match.route.id];\n    return (route.imports || []).concat([route.module]);\n  }).flat(1);\n  let preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);\n  return isHydrated ? null : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"link\", {\n    rel: \"modulepreload\",\n    href: manifest.url,\n    crossOrigin: props.crossOrigin\n  }), /*#__PURE__*/React.createElement(\"link\", {\n    rel: \"modulepreload\",\n    href: manifest.entry.module,\n    crossOrigin: props.crossOrigin\n  }), dedupe(preloads).map(path => /*#__PURE__*/React.createElement(\"link\", {\n    key: path,\n    rel: \"modulepreload\",\n    href: path,\n    crossOrigin: props.crossOrigin\n  })), initialScripts, deferredScripts);\n}\nfunction DeferredHydrationScript({\n  dataKey,\n  deferredData,\n  routeId,\n  scriptProps,\n  serializeData,\n  serializeError\n}) {\n  if (typeof document === \"undefined\" && deferredData && dataKey && routeId) {\n    invariant(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`);\n  }\n  return /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback:\n    // This makes absolutely no sense. The server renders null as a fallback,\n    // but when hydrating, we need to render a script tag to avoid a hydration issue.\n    // To reproduce a hydration mismatch, just render null as a fallback.\n    typeof document === \"undefined\" && deferredData && dataKey && routeId ? null : /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n      async: true,\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: \" \"\n      }\n    }))\n  }, typeof document === \"undefined\" && deferredData && dataKey && routeId ? /*#__PURE__*/React.createElement(Await, {\n    resolve: deferredData.data[dataKey],\n    errorElement: /*#__PURE__*/React.createElement(ErrorDeferredHydrationScript, {\n      dataKey: dataKey,\n      routeId: routeId,\n      scriptProps: scriptProps,\n      serializeError: serializeError\n    }),\n    children: data => {\n      return /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n        async: true,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n          __html: serializeData(routeId, dataKey, data)\n        }\n      }));\n    }\n  }) : /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n    async: true,\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: \" \"\n    }\n  })));\n}\nfunction ErrorDeferredHydrationScript({\n  dataKey,\n  routeId,\n  scriptProps,\n  serializeError\n}) {\n  let error = useAsyncError();\n  return /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: serializeError(routeId, dataKey, error)\n    }\n  }));\n}\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n *\n * @see https://remix.run/hooks/use-matches\n */\nfunction useMatches() {\n  return useMatches$1();\n}\n\n/**\n * Returns the JSON parsed data from the current route's `loader`.\n *\n * @see https://remix.run/hooks/use-loader-data\n */\nfunction useLoaderData() {\n  return useLoaderData$1();\n}\n\n/**\n * Returns the loaderData for the given routeId.\n *\n * @see https://remix.run/hooks/use-route-loader-data\n */\nfunction useRouteLoaderData(routeId) {\n  return useRouteLoaderData$1(routeId);\n}\n\n/**\n * Returns the JSON parsed data from the current route's `action`.\n *\n * @see https://remix.run/hooks/use-action-data\n */\nfunction useActionData() {\n  return useActionData$1();\n}\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n *\n * @see https://remix.run/hooks/use-fetcher\n */\nfunction useFetcher(opts = {}) {\n  return useFetcher$1(opts);\n}\n\n/**\n * This component connects your app to the Remix asset server and\n * automatically reloads the page when files change in development.\n * In production, it renders null, so you can safely render it always in your root route.\n *\n * @see https://remix.run/docs/components/live-reload\n */\nconst LiveReload =\n// Dead Code Elimination magic for production builds.\n// This way devs don't have to worry about doing the NODE_ENV check themselves.\nprocess.env.NODE_ENV !== \"development\" ? () => null : function LiveReload({\n  origin,\n  port,\n  timeoutMs = 1000,\n  nonce = undefined\n}) {\n  // @ts-expect-error\n  let isViteClient = import.meta && import.meta.env !== undefined;\n  if (isViteClient) {\n    console.warn([\"`<LiveReload />` is obsolete when using Vite and can conflict with Vite's built-in HMR runtime.\", \"\", \"Remove `<LiveReload />` from your code and instead only use `<Scripts />`.\", \"Then refresh the page to remove lingering scripts from `<LiveReload />`.\"].join(\"\\n\"));\n    return null;\n  }\n  origin ??= process.env.REMIX_DEV_ORIGIN;\n  let js = String.raw;\n  return /*#__PURE__*/React.createElement(\"script\", {\n    nonce: nonce,\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: js`\n                function remixLiveReloadConnect(config) {\n                  let LIVE_RELOAD_ORIGIN = ${JSON.stringify(origin)};\n                  let protocol =\n                    LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).protocol.replace(/^http/, \"ws\") :\n                    location.protocol === \"https:\" ? \"wss:\" : \"ws:\"; // remove in v2?\n                  let hostname = LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).hostname : location.hostname;\n                  let url = new URL(protocol + \"//\" + hostname + \"/socket\");\n\n                  url.port =\n                    ${port} ||\n                    (LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).port : 8002);\n\n                  let ws = new WebSocket(url.href);\n                  ws.onmessage = async (message) => {\n                    let event = JSON.parse(message.data);\n                    if (event.type === \"LOG\") {\n                      console.log(event.message);\n                    }\n                    if (event.type === \"RELOAD\") {\n                      console.log(\"\uD83D\uDCBF Reloading window ...\");\n                      window.location.reload();\n                    }\n                    if (event.type === \"HMR\") {\n                      if (!window.__hmr__ || !window.__hmr__.contexts) {\n                        console.log(\"\uD83D\uDCBF [HMR] No HMR context, reloading window ...\");\n                        window.location.reload();\n                        return;\n                      }\n                      if (!event.updates || !event.updates.length) return;\n                      let updateAccepted = false;\n                      let needsRevalidation = new Set();\n                      for (let update of event.updates) {\n                        console.log(\"[HMR] \" + update.reason + \" [\" + update.id +\"]\")\n                        if (update.revalidate) {\n                          needsRevalidation.add(update.routeId);\n                          console.log(\"[HMR] Revalidating [\" + update.routeId + \"]\");\n                        }\n                        let imported = await import(update.url +  '?t=' + event.assetsManifest.hmr.timestamp);\n                        if (window.__hmr__.contexts[update.id]) {\n                          let accepted = window.__hmr__.contexts[update.id].emit(\n                            imported\n                          );\n                          if (accepted) {\n                            console.log(\"[HMR] Update accepted by\", update.id);\n                            updateAccepted = true;\n                          }\n                        }\n                      }\n                      if (event.assetsManifest && window.__hmr__.contexts[\"remix:manifest\"]) {\n                        let accepted = window.__hmr__.contexts[\"remix:manifest\"].emit(\n                          { needsRevalidation, assetsManifest: event.assetsManifest }\n                        );\n                        if (accepted) {\n                          console.log(\"[HMR] Update accepted by\", \"remix:manifest\");\n                          updateAccepted = true;\n                        }\n                      }\n                      if (!updateAccepted) {\n                        console.log(\"[HMR] Update rejected, reloading...\");\n                        window.location.reload();\n                      }\n                    }\n                  };\n                  ws.onopen = () => {\n                    if (config && typeof config.onOpen === \"function\") {\n                      config.onOpen();\n                    }\n                  };\n                  ws.onclose = (event) => {\n                    if (event.code === 1006) {\n                      console.log(\"Remix dev asset server web socket closed. Reconnecting...\");\n                      setTimeout(\n                        () =>\n                          remixLiveReloadConnect({\n                            onOpen: () => window.location.reload(),\n                          }),\n                      ${String(timeoutMs)}\n                      );\n                    }\n                  };\n                  ws.onerror = (error) => {\n                    console.log(\"Remix dev asset server web socket error:\");\n                    console.error(error);\n                  };\n                }\n                remixLiveReloadConnect();\n              `\n    }\n  });\n};\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\nexport { Await, Link, Links, LiveReload, Meta, NavLink, PrefetchPageLinks, RemixContext, Scripts, composeEventHandlers, useActionData, useFetcher, useLoaderData, useMatches, useRemixContext, useRouteLoaderData };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport { invariant as default };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parsePath } from 'react-router-dom';\nimport { loadRouteModule } from './routeModules.js';\n\n/**\n * Represents a `<link>` element.\n *\n * WHATWG Specification: https://html.spec.whatwg.org/multipage/semantics.html#the-link-element\n */\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Gets all the links for a set of matches. The modules are assumed to have been\n * loaded already.\n */\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map((match) => {\n    var _module$links;\n    let module = routeModules[match.route.id];\n    let route = manifest.routes[match.route.id];\n    return [route.css ? route.css.map((href) => ({\n      rel: \"stylesheet\",\n      href\n    })) : [], (module === null || module === void 0 ? void 0 : (_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || []];\n  }).flat(2);\n  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);\n  return dedupeLinkDescriptors(descriptors, preloads);\n}\nasync function prefetchStyleLinks(route, routeModule) {\n  var _route$css, _routeModule$links;\n  if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n  let descriptors = [((_route$css = route.css) === null || _route$css === void 0 ? void 0 : _route$css.map((href) => ({\n    rel: \"stylesheet\",\n    href\n  }))) ?? [], ((_routeModule$links = routeModule.links) === null || _routeModule$links === void 0 ? void 0 : _routeModule$links.call(routeModule)) ?? []].flat(1);\n  if (descriptors.length === 0) return;\n  let styleLinks = [];\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({\n        ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  }\n\n  // don't block for non-matching media queries, or for stylesheets that are\n  // already in the DOM (active route revalidations)\n  let matchingLinks = styleLinks.filter((link) => (!link.media || window.matchMedia(link.media).matches) && !document.querySelector(`link[rel=\"stylesheet\"][href=\"${link.href}\"]`));\n  await Promise.all(matchingLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n  return new Promise((resolve) => {\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n    function removeLink() {\n      // if a navigation interrupts this prefetch React will update the <head>\n      // and remove the link we put in there manually, so we check if it's still\n      // there before trying to remove it\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n    document.head.appendChild(link);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  if (object == null) {\n    return false;\n  }\n\n  // <link> may not have an href if <link rel=\"preload\"> is used with imageSrcSet + imageSizes\n  // https://github.com/remix-run/remix/issues/184\n  // https://html.spec.whatwg.org/commit-snapshots/cb4f5ff75de5f4cbd7013c4abad02f21c77d4d1c/#attr-link-imagesrcset\n  if (object.href == null) {\n    return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n  }\n  return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n  let links = await Promise.all(matches.map(async (match) => {\n    let mod = await loadRouteModule(manifest.routes[match.route.id], routeModules);\n    return mod.links ? mod.links() : [];\n  }));\n  return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === \"stylesheet\" || link.rel === \"preload\").map((link) => link.rel === \"stylesheet\" ? {\n    ...link,\n    rel: \"prefetch\",\n    as: \"style\"\n  } : {\n    ...link,\n    rel: \"prefetch\"\n  }));\n}\n\n// This is ridiculously identical to transition.ts `filterMatchesToLoad`\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n  let path = parsePathPatch(page);\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n  let matchPathChanged = (match, index) => {\n    var _currentMatches$index;\n    return (\n      // param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname ||\n      // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith(\"*\")) && currentMatches[index].params[\"*\"] !== match.params[\"*\"]);\n\n  };\n\n  // NOTE: keep this mostly up-to-date w/ the transition data diff, but this\n  // version doesn't care about submissions\n  let newMatches = mode === \"data\" && location.search !== path.search ?\n  // this is really similar to stuff in transition.ts, maybe somebody smarter\n  // than me (or in less of a hurry) can share some of it. You're the best.\n  nextMatches.filter((match, index) => {\n    let manifestRoute = manifest.routes[match.route.id];\n    if (!manifestRoute.hasLoader) {\n      return false;\n    }\n    if (isNew(match, index) || matchPathChanged(match, index)) {\n      return true;\n    }\n    if (match.route.shouldRevalidate) {\n      var _currentMatches$;\n      let routeChoice = match.route.shouldRevalidate({\n        currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n        currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},\n        nextUrl: new URL(page, window.origin),\n        nextParams: match.params,\n        defaultShouldRevalidate: true\n      });\n      if (typeof routeChoice === \"boolean\") {\n        return routeChoice;\n      }\n    }\n    return true;\n  }) : nextMatches.filter((match, index) => {\n    let manifestRoute = manifest.routes[match.route.id];\n    return (mode === \"assets\" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));\n  });\n  return newMatches;\n}\nfunction getDataLinkHrefs(page, matches, manifest) {\n  let path = parsePathPatch(page);\n  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {\n    let {\n      pathname,\n      search\n    } = path;\n    let searchParams = new URLSearchParams(search);\n    searchParams.set(\"_data\", match.route.id);\n    return `${pathname}?${searchParams}`;\n  }));\n}\nfunction getModuleLinkHrefs(matches, manifestPatch) {\n  return dedupeHrefs(matches.map((match) => {\n    let route = manifestPatch.routes[match.route.id];\n    let hrefs = [route.module];\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n    return hrefs;\n  }).flat(1));\n}\n\n// The `<Script>` will render rel=modulepreload for the current page, we don't\n// need to include them in a page prefetch, this gives us the list to remove\n// while deduping.\nfunction getCurrentPageModulePreloadHrefs(matches, manifest) {\n  return dedupeHrefs(matches.map((match) => {\n    let route = manifest.routes[match.route.id];\n    let hrefs = [route.module];\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n    return hrefs;\n  }).flat(1));\n}\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\nfunction sortKeys(obj) {\n  let sorted = {};\n  let keys = Object.keys(obj).sort();\n  for (let key of keys) {\n    sorted[key] = obj[key];\n  }\n  return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n  let set = new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n    let key = JSON.stringify(sortKeys(descriptor));\n    if (!set.has(key)) {\n      set.add(key);\n      deduped.push({\n        key,\n        link: descriptor\n      });\n    }\n    return deduped;\n  }, []);\n}\n\n// https://github.com/remix-run/history/issues/897\nfunction parsePathPatch(href) {\n  let path = parsePath(href);\n  if (path.search === undefined) path.search = \"\";\n  return path;\n}\n\n// Detect if this browser supports <link rel=\"preload\"> (or has it enabled).\n// Originally added to handle the firefox `network.preload` config:\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1847811\nlet _isPreloadSupported;\nfunction isPreloadSupported() {\n  if (_isPreloadSupported !== undefined) {\n    return _isPreloadSupported;\n  }\n  let el = document.createElement(\"link\");\n  _isPreloadSupported = el.relList.supports(\"preload\");\n  el = null;\n  return _isPreloadSupported;\n}\n\nexport { getDataLinkHrefs, getKeyedLinksForMatches, getKeyedPrefetchLinks, getModuleLinkHrefs, getNewMatchesForLinks, isPageLinkDescriptor, prefetchStyleLinks };", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * A function that handles data mutations for a route on the client\n */\n\n/**\n * Arguments passed to a route `clientAction` function\n */\n\n/**\n * A function that loads data for a route on the client\n */\n\n/**\n * Arguments passed to a route `clientLoader` function\n */\n\n/**\n * ErrorBoundary to display for this route\n */\n\n/**\n * `<Route HydrateFallback>` component to render on initial loads\n * when client loaders are present\n */\n\n/**\n * Optional, root-only `<Route Layout>` component to wrap the root content in.\n * Useful for defining the <html>/<head>/<body> document shell shared by the\n * Component, HydrateFallback, and ErrorBoundary\n */\n\n/**\n * A function that defines `<link>` tags to be inserted into the `<head>` of\n * the document on route transitions.\n *\n * @see https://remix.run/route/meta\n */\n\n/**\n * A React component that is rendered for a route.\n */\n\n/**\n * An arbitrary object that is associated with a route.\n *\n * @see https://remix.run/route/handle\n */\n\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n  try {\n    let routeModule = await import( /* webpackIgnore: true */route.module);\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    // User got caught in the middle of a deploy and the CDN no longer has the\n    // asset we're trying to import! Reload from the server and the user\n    // (should) get the new manifest--unless the developer purged the static\n    // assets, the manifest path, but not the documents \uD83D\uDE2C\n    if (window.__remixContext.isSpaMode &&\n    // @ts-expect-error\n    typeof import.meta.hot !== \"undefined\") {\n      // In SPA Mode (which implies vite) we don't want to perform a hard reload\n      // on dev-time errors since it's a vite compilation error and a reload is\n      // just going to fail with the same issue.  Let the UI bubble to the error\n      // boundary and let them see the error in the overlay or the dev server log\n      console.error(`Error loading route module \\`${route.module}\\`:`, error);\n      throw error;\n    }\n    window.location.reload();\n    return new Promise(() => {\n      // check out of this hook cause the DJs never gonna re[s]olve this\n    });\n  }\n}\n\nexport { loadRouteModule };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// This escapeHtml utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\n// We've chosen to inline the utility here to reduce the number of npm dependencies we have,\n// slightly decrease the code size compared the original package and make it esm compatible.\n\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n  return {\n    __html: html\n  };\n}\n\nexport { createHtml, escapeHtml };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_ErrorResponseImpl, redirect } from '@remix-run/router';\nimport { UNSAFE_SingleFetchRedirectSymbol } from '@remix-run/server-runtime';\nimport { decode } from 'turbo-stream';\nimport { createRequestInit } from './data.js';\nimport { escapeHtml } from './markup.js';\nimport invariant from './invariant.js';\n\n// clientLoader\n\nlet defineClientLoader = clientLoader => clientLoader;\n\n// clientAction\n\nlet defineClientAction = clientAction => clientAction;\n// StreamTransfer recursively renders down chunks of the `serverHandoffStream`\n// into the client-side `streamController`\nfunction StreamTransfer({\n  context,\n  identifier,\n  reader,\n  textDecoder,\n  nonce\n}) {\n  // If the user didn't render the <Scripts> component then we don't have to\n  // bother streaming anything in\n  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n    return null;\n  }\n  if (!context.renderMeta.streamCache) {\n    context.renderMeta.streamCache = {};\n  }\n  let {\n    streamCache\n  } = context.renderMeta;\n  let promise = streamCache[identifier];\n  if (!promise) {\n    promise = streamCache[identifier] = reader.read().then(result => {\n      streamCache[identifier].result = {\n        done: result.done,\n        value: textDecoder.decode(result.value, {\n          stream: true\n        })\n      };\n    }).catch(e => {\n      streamCache[identifier].error = e;\n    });\n  }\n  if (promise.error) {\n    throw promise.error;\n  }\n  if (promise.result === undefined) {\n    throw promise;\n  }\n  let {\n    done,\n    value\n  } = promise.result;\n  let scriptTag = value ? /*#__PURE__*/React.createElement(\"script\", {\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: `window.__remixContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`\n    }\n  }) : null;\n  if (done) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, scriptTag, /*#__PURE__*/React.createElement(\"script\", {\n      nonce: nonce,\n      dangerouslySetInnerHTML: {\n        __html: `window.__remixContext.streamController.close();`\n      }\n    }));\n  } else {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, scriptTag, /*#__PURE__*/React.createElement(React.Suspense, null, /*#__PURE__*/React.createElement(StreamTransfer, {\n      context: context,\n      identifier: identifier + 1,\n      reader: reader,\n      textDecoder: textDecoder,\n      nonce: nonce\n    })));\n  }\n}\nfunction getSingleFetchDataStrategy(manifest, routeModules) {\n  return async ({\n    request,\n    matches\n  }) => request.method !== \"GET\" ? singleFetchActionStrategy(request, matches) : singleFetchLoaderStrategy(manifest, routeModules, request, matches);\n}\n\n// Actions are simple since they're singular calls to the server\nfunction singleFetchActionStrategy(request, matches) {\n  return Promise.all(matches.map(async m => {\n    let actionStatus;\n    let result = await m.resolve(async handler => {\n      let result = await handler(async () => {\n        let url = singleFetchUrl(request.url);\n        let init = await createRequestInit(request);\n        let {\n          data,\n          status\n        } = await fetchAndDecode(url, init);\n        actionStatus = status;\n        return unwrapSingleFetchResult(data, m.route.id);\n      });\n      return {\n        type: \"data\",\n        result,\n        status: actionStatus\n      };\n    });\n    return {\n      ...result,\n      // Proxy along the action HTTP response status for thrown errors\n      status: actionStatus\n    };\n  }));\n}\n\n// Loaders are trickier since we only want to hit the server once, so we\n// create a singular promise for all server-loader routes to latch onto.\nfunction singleFetchLoaderStrategy(manifest, routeModules, request, matches) {\n  let singleFetchPromise;\n  return Promise.all(matches.map(async m => m.resolve(async handler => {\n    let result;\n    let url = stripIndexParam(singleFetchUrl(request.url));\n\n    // When a route has a client loader, it calls it's singular server loader\n    if (manifest.routes[m.route.id].hasClientLoader) {\n      result = await handler(async () => {\n        url.searchParams.set(\"_routes\", m.route.id);\n        let {\n          data\n        } = await fetchAndDecode(url);\n        return unwrapSingleFetchResults(data, m.route.id);\n      });\n    } else {\n      result = await handler(async () => {\n        // Otherwise we let multiple routes hook onto the same promise\n        if (!singleFetchPromise) {\n          url = addRevalidationParam(manifest, routeModules, matches.map(m => m.route), matches.filter(m => m.shouldLoad).map(m => m.route), url);\n          singleFetchPromise = fetchAndDecode(url).then(({\n            data\n          }) => data);\n        }\n        let results = await singleFetchPromise;\n        return unwrapSingleFetchResults(results, m.route.id);\n      });\n    }\n    return {\n      type: \"data\",\n      result\n    };\n  })));\n}\nfunction stripIndexParam(url) {\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  return url;\n}\n\n// Determine which routes we want to load so we can add a `?_routes` search param\n// for fine-grained revalidation if necessary. There's some nuance to this decision:\n//\n//  - The presence of `shouldRevalidate` and `clientLoader` functions are the only\n//    way to trigger fine-grained single fetch loader calls.  without either of\n//    these on the route matches we just always ask for the full `.data` request.\n//  - If any routes have a `shouldRevalidate` or `clientLoader` then we do a\n//    comparison of the routes we matched and the routes we're aiming to load\n//  - If they don't match up, then we add the `_routes` param or fine-grained\n//    loading\n//  - This is used by the single fetch implementation above and by the\n//    `<PrefetchPageLinksImpl>` component so we can prefetch routes using the\n//    same logic\nfunction addRevalidationParam(manifest, routeModules, matchedRoutes, loadRoutes, url) {\n  let genRouteIds = arr => arr.filter(id => manifest.routes[id].hasLoader).join(\",\");\n\n  // Look at the `routeModules` for `shouldRevalidate` here instead of the manifest\n  // since HDR adds a wrapper for `shouldRevalidate` even if the route didn't have one\n  // initially.\n  // TODO: We probably can get rid of that wrapper once we're strictly on on\n  // single-fetch in v3 and just leverage a needsRevalidation data structure here\n  // to determine what to fetch\n  let needsParam = matchedRoutes.some(r => {\n    var _routeModules$r$id, _manifest$routes$r$id;\n    return ((_routeModules$r$id = routeModules[r.id]) === null || _routeModules$r$id === void 0 ? void 0 : _routeModules$r$id.shouldRevalidate) || ((_manifest$routes$r$id = manifest.routes[r.id]) === null || _manifest$routes$r$id === void 0 ? void 0 : _manifest$routes$r$id.hasClientLoader);\n  });\n  if (!needsParam) {\n    return url;\n  }\n  let matchedIds = genRouteIds(matchedRoutes.map(r => r.id));\n  let loadIds = genRouteIds(loadRoutes.filter(r => {\n    var _manifest$routes$r$id2;\n    return !((_manifest$routes$r$id2 = manifest.routes[r.id]) !== null && _manifest$routes$r$id2 !== void 0 && _manifest$routes$r$id2.hasClientLoader);\n  }).map(r => r.id));\n  if (matchedIds !== loadIds) {\n    url.searchParams.set(\"_routes\", loadIds);\n  }\n  return url;\n}\nfunction singleFetchUrl(reqUrl) {\n  let url = typeof reqUrl === \"string\" ? new URL(reqUrl, window.location.origin) : reqUrl;\n  url.pathname = `${url.pathname === \"/\" ? \"_root\" : url.pathname}.data`;\n  return url;\n}\nasync function fetchAndDecode(url, init) {\n  let res = await fetch(url, init);\n  // Don't do a hard check against the header here.  We'll get `text/x-turbo`\n  // when we have a running server, but if folks want to prerender `.data` files\n  // and serve them from a CDN we should let them come back with whatever\n  // Content-Type their CDN provides and not force them to make sure `.data`\n  // files are served as `text/x-turbo`.  We'll throw if we can't decode anyway.\n  invariant(res.body, \"No response body to decode\");\n  try {\n    let decoded = await decodeViaTurboStream(res.body, window);\n    return {\n      status: res.status,\n      data: decoded.value\n    };\n  } catch (e) {\n    console.error(e);\n    throw new Error(`Unable to decode turbo-stream response from URL: ${url.toString()}`);\n  }\n}\n\n// Note: If you change this function please change the corresponding\n// encodeViaTurboStream function in server-runtime\nfunction decodeViaTurboStream(body, global) {\n  return decode(body, {\n    plugins: [(type, ...rest) => {\n      // Decode Errors back into Error instances using the right type and with\n      // the right (potentially undefined) stacktrace\n      if (type === \"SanitizedError\") {\n        let [name, message, stack] = rest;\n        let Constructor = Error;\n        // @ts-expect-error\n        if (name && name in global && typeof global[name] === \"function\") {\n          // @ts-expect-error\n          Constructor = global[name];\n        }\n        let error = new Constructor(message);\n        error.stack = stack;\n        return {\n          value: error\n        };\n      }\n      if (type === \"ErrorResponse\") {\n        let [data, status, statusText] = rest;\n        return {\n          value: new UNSAFE_ErrorResponseImpl(status, statusText, data)\n        };\n      }\n      if (type === \"SingleFetchRedirect\") {\n        return {\n          value: {\n            [UNSAFE_SingleFetchRedirectSymbol]: rest[0]\n          }\n        };\n      }\n    }]\n  });\n}\nfunction unwrapSingleFetchResults(results, routeId) {\n  let redirect = results[UNSAFE_SingleFetchRedirectSymbol];\n  if (redirect) {\n    return unwrapSingleFetchResult(redirect, routeId);\n  }\n  return results[routeId] !== undefined ? unwrapSingleFetchResult(results[routeId], routeId) : null;\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n  if (\"error\" in result) {\n    throw result.error;\n  } else if (\"redirect\" in result) {\n    let headers = {};\n    if (result.revalidate) {\n      headers[\"X-Remix-Revalidate\"] = \"yes\";\n    }\n    if (result.reload) {\n      headers[\"X-Remix-Reload-Document\"] = \"yes\";\n    }\n    return redirect(result.redirect, {\n      status: result.status,\n      headers\n    });\n  } else if (\"data\" in result) {\n    return result.data;\n  } else {\n    throw new Error(`No response found for routeId \"${routeId}\"`);\n  }\n}\n\nexport { StreamTransfer, addRevalidationParam, decodeViaTurboStream, defineClientAction, defineClientLoader, getSingleFetchDataStrategy, singleFetchUrl };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { AbortedDeferredError, UNSAFE_DeferredData } from '@remix-run/router';\n\n/**\n * Data for a route that was returned from a `loader()`.\n */\n\nfunction isCatchResponse(response) {\n  return response.headers.get(\"X-Remix-Catch\") != null;\n}\nfunction isErrorResponse(response) {\n  return response.headers.get(\"X-Remix-Error\") != null;\n}\nfunction isNetworkErrorResponse(response) {\n  // If we reach the Remix server, we can safely identify response types via the\n  // X-Remix-Error/X-Remix-Catch headers.  However, if we never reach the Remix\n  // server, and instead receive a 4xx/5xx from somewhere in between (like\n  // Cloudflare), then we get a false negative in the isErrorResponse check and\n  // we incorrectly assume that the user returns the 4xx/5xx response and\n  // consider it successful.  To alleviate this, we add X-Remix-Response to any\n  // non-Error/non-Catch responses coming back from the server.  If we don't\n  // see this, we can conclude that a 4xx/5xx response never actually reached\n  // the Remix server and we can bubble it up as an error.\n  return isResponse(response) && response.status >= 400 && response.headers.get(\"X-Remix-Error\") == null && response.headers.get(\"X-Remix-Catch\") == null && response.headers.get(\"X-Remix-Response\") == null;\n}\nfunction isRedirectResponse(response) {\n  return response.headers.get(\"X-Remix-Redirect\") != null;\n}\nfunction isDeferredResponse(response) {\n  var _response$headers$get;\n  return !!((_response$headers$get = response.headers.get(\"Content-Type\")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\\/remix-deferred/));\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nasync function fetchData(request, routeId, retry = 0) {\n  let url = new URL(request.url);\n  url.searchParams.set(\"_data\", routeId);\n  if (retry > 0) {\n    // Retry up to 3 times waiting 50, 250, 1250 ms\n    // between retries for a total of 1550 ms before giving up.\n    await new Promise(resolve => setTimeout(resolve, 5 ** retry * 10));\n  }\n  let init = await createRequestInit(request);\n  let revalidation = window.__remixRevalidation;\n  let response = await fetch(url.href, init).catch(error => {\n    if (typeof revalidation === \"number\" && revalidation === window.__remixRevalidation && (error === null || error === void 0 ? void 0 : error.name) === \"TypeError\" && retry < 3) {\n      return fetchData(request, routeId, retry + 1);\n    }\n    throw error;\n  });\n  if (isErrorResponse(response)) {\n    let data = await response.json();\n    let error = new Error(data.message);\n    error.stack = data.stack;\n    return error;\n  }\n  if (isNetworkErrorResponse(response)) {\n    let text = await response.text();\n    let error = new Error(text);\n    error.stack = undefined;\n    return error;\n  }\n  return response;\n}\nasync function createRequestInit(request) {\n  let init = {\n    signal: request.signal\n  };\n  if (request.method !== \"GET\") {\n    init.method = request.method;\n    let contentType = request.headers.get(\"Content-Type\");\n\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      init.headers = {\n        \"Content-Type\": contentType\n      };\n      init.body = JSON.stringify(await request.json());\n    } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n      init.headers = {\n        \"Content-Type\": contentType\n      };\n      init.body = await request.text();\n    } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n      init.body = new URLSearchParams(await request.text());\n    } else {\n      init.body = await request.formData();\n    }\n  }\n  return init;\n}\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nasync function parseDeferredReadableStream(stream) {\n  if (!stream) {\n    throw new Error(\"parseDeferredReadableStream requires stream argument\");\n  }\n  let deferredData;\n  let deferredResolvers = {};\n  try {\n    let sectionReader = readStreamSections(stream);\n\n    // Read the first section to get the critical data\n    let initialSectionResult = await sectionReader.next();\n    let initialSection = initialSectionResult.value;\n    if (!initialSection) throw new Error(\"no critical data\");\n    let criticalData = JSON.parse(initialSection);\n\n    // Setup deferred data and resolvers for later based on the critical data\n    if (typeof criticalData === \"object\" && criticalData !== null) {\n      for (let [eventKey, value] of Object.entries(criticalData)) {\n        if (typeof value !== \"string\" || !value.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX)) {\n          continue;\n        }\n        deferredData = deferredData || {};\n        deferredData[eventKey] = new Promise((resolve, reject) => {\n          deferredResolvers[eventKey] = {\n            resolve: value => {\n              resolve(value);\n              delete deferredResolvers[eventKey];\n            },\n            reject: error => {\n              reject(error);\n              delete deferredResolvers[eventKey];\n            }\n          };\n        });\n      }\n    }\n\n    // Read the rest of the stream and resolve deferred promises\n    void (async () => {\n      try {\n        for await (let section of sectionReader) {\n          // Determine event type and data\n          let [event, ...sectionDataStrings] = section.split(\":\");\n          let sectionDataString = sectionDataStrings.join(\":\");\n          let data = JSON.parse(sectionDataString);\n          if (event === \"data\") {\n            for (let [key, value] of Object.entries(data)) {\n              if (deferredResolvers[key]) {\n                deferredResolvers[key].resolve(value);\n              }\n            }\n          } else if (event === \"error\") {\n            for (let [key, value] of Object.entries(data)) {\n              let err = new Error(value.message);\n              err.stack = value.stack;\n              if (deferredResolvers[key]) {\n                deferredResolvers[key].reject(err);\n              }\n            }\n          }\n        }\n        for (let [key, resolver] of Object.entries(deferredResolvers)) {\n          resolver.reject(new AbortedDeferredError(`Deferred ${key} will never be resolved`));\n        }\n      } catch (error) {\n        // Reject any existing deferred promises if something blows up\n        for (let resolver of Object.values(deferredResolvers)) {\n          resolver.reject(error);\n        }\n      }\n    })();\n    return new UNSAFE_DeferredData({\n      ...criticalData,\n      ...deferredData\n    });\n  } catch (error) {\n    for (let resolver of Object.values(deferredResolvers)) {\n      resolver.reject(error);\n    }\n    throw error;\n  }\n}\nasync function* readStreamSections(stream) {\n  let reader = stream.getReader();\n  let buffer = [];\n  let sections = [];\n  let closed = false;\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  let readStreamSection = async () => {\n    if (sections.length > 0) return sections.shift();\n\n    // Read from the stream until we have at least one complete section to process\n    while (!closed && sections.length === 0) {\n      let chunk = await reader.read();\n      if (chunk.done) {\n        closed = true;\n        break;\n      }\n      // Buffer the raw chunks\n      buffer.push(chunk.value);\n      try {\n        // Attempt to split off a section from the buffer\n        let bufferedString = decoder.decode(mergeArrays(...buffer));\n        let splitSections = bufferedString.split(\"\\n\\n\");\n        if (splitSections.length >= 2) {\n          // We have a complete section, so add it to the sections array\n          sections.push(...splitSections.slice(0, -1));\n          // Remove the section from the buffer and store the rest for future processing\n          buffer = [encoder.encode(splitSections.slice(-1).join(\"\\n\\n\"))];\n        }\n\n        // If we successfully parsed at least one section, break out of reading the stream\n        // to allow upstream processing of the processable sections\n        if (sections.length > 0) {\n          break;\n        }\n      } catch {\n        // If we failed to parse the buffer it was because we failed to decode the stream\n        // because we are missing bytes that we haven't yet received, so continue reading\n        // from the stream until we have a complete section\n        continue;\n      }\n    }\n\n    // If we have a complete section, return it\n    if (sections.length > 0) {\n      return sections.shift();\n    }\n\n    // If we have no complete section, but we have no more chunks to process,\n    // split those sections and clear out the buffer as there is no more data\n    // to process. If this errors, let it bubble up as the stream ended\n    // without valid data\n    if (buffer.length > 0) {\n      let bufferedString = decoder.decode(mergeArrays(...buffer));\n      sections = bufferedString.split(\"\\n\\n\").filter(s => s);\n      buffer = [];\n    }\n\n    // Return any remaining sections that have been processed\n    return sections.shift();\n  };\n  let section = await readStreamSection();\n  while (section) {\n    yield section;\n    section = await readStreamSection();\n  }\n}\nfunction mergeArrays(...arrays) {\n  let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));\n  let offset = 0;\n  for (let arr of arrays) {\n    out.set(arr, offset);\n    offset += arr.length;\n  }\n  return out;\n}\n\nexport { createRequestInit, fetchData, isCatchResponse, isDeferredData, isDeferredResponse, isErrorResponse, isNetworkErrorResponse, isRedirectResponse, isResponse, parseDeferredReadableStream };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { isRouteErrorResponse } from 'react-router-dom';\nimport { useRemixContext, Scripts } from './components.js';\n\nclass RemixErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: props.error || null,\n      location: props.location\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application (even the HTML!) that will have no effect--the error page\n    // continues to display. This gives us a mechanism to recover from the error\n    // when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error || null,\n        location: props.location\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location\n    };\n  }\n  render() {\n    if (this.state.error) {\n      return /*#__PURE__*/React.createElement(RemixRootDefaultErrorBoundary, {\n        error: this.state.error\n      });\n    } else {\n      return this.props.children;\n    }\n  }\n}\n\n/**\n * When app's don't provide a root level ErrorBoundary, we default to this.\n */\nfunction RemixRootDefaultErrorBoundary({\n  error\n}) {\n  console.error(error);\n  let heyDeveloper = /*#__PURE__*/React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n        console.log(\n          \"\uD83D\uDCBF Hey developer \uD83D\uDC4B. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information.\"\n        );\n      `\n    }\n  });\n  if (isRouteErrorResponse(error)) {\n    return /*#__PURE__*/React.createElement(BoundaryShell, {\n      title: \"Unhandled Thrown Response!\"\n    }, /*#__PURE__*/React.createElement(\"h1\", {\n      style: {\n        fontSize: \"24px\"\n      }\n    }, error.status, \" \", error.statusText), heyDeveloper);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /*#__PURE__*/React.createElement(BoundaryShell, {\n    title: \"Application Error!\"\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    style: {\n      fontSize: \"24px\"\n    }\n  }, \"Application Error\"), /*#__PURE__*/React.createElement(\"pre\", {\n    style: {\n      padding: \"2rem\",\n      background: \"hsla(10, 50%, 50%, 0.1)\",\n      color: \"red\",\n      overflow: \"auto\"\n    }\n  }, errorInstance.stack), heyDeveloper);\n}\nfunction BoundaryShell({\n  title,\n  renderScripts,\n  children\n}) {\n  var _routeModules$root;\n  let {\n    routeModules\n  } = useRemixContext();\n  if ((_routeModules$root = routeModules.root) !== null && _routeModules$root !== void 0 && _routeModules$root.Layout) {\n    return children;\n  }\n  return /*#__PURE__*/React.createElement(\"html\", {\n    lang: \"en\"\n  }, /*#__PURE__*/React.createElement(\"head\", null, /*#__PURE__*/React.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  }), /*#__PURE__*/React.createElement(\"meta\", {\n    name: \"viewport\",\n    content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n  }), /*#__PURE__*/React.createElement(\"title\", null, title)), /*#__PURE__*/React.createElement(\"body\", null, /*#__PURE__*/React.createElement(\"main\", {\n    style: {\n      fontFamily: \"system-ui, sans-serif\",\n      padding: \"2rem\"\n    }\n  }, children, renderScripts ? /*#__PURE__*/React.createElement(Scripts, null) : null)));\n}\n\nexport { BoundaryShell, RemixErrorBoundary, RemixRootDefaultErrorBoundary };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in remix-server-runtime/errors.ts :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexport { deserializeErrors };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\nimport { useRouteError, redirect } from 'react-router-dom';\nimport { loadRouteModule } from './routeModules.js';\nimport { fetchData, isRedirectResponse, isCatchResponse, isDeferredResponse, parseDeferredReadableStream, isDeferredData, isResponse } from './data.js';\nimport { prefetchStyleLinks } from './links.js';\nimport { RemixRootDefaultErrorBoundary } from './errorBoundaries.js';\nimport { RemixRootDefaultHydrateFallback } from './fallback.js';\nimport invariant from './invariant.js';\n\n// NOTE: make sure to change the Route in server-runtime if you change this\n\n// NOTE: make sure to change the EntryRoute in server-runtime if you change this\n\n// Create a map of routes by parentId to use recursively instead of\n// repeatedly filtering the manifest.\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach(route => {\n    let parentId = route.parentId || \"\";\n    if (!routes[parentId]) {\n      routes[parentId] = [];\n    }\n    routes[parentId].push(route);\n  });\n  return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n  let Component = getRouteModuleComponent(routeModule);\n  // HydrateFallback can only exist on the root route in SPA Mode\n  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : undefined;\n  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? () => /*#__PURE__*/React.createElement(RemixRootDefaultErrorBoundary, {\n    error: useRouteError()\n  }) : undefined;\n  if (route.id === \"root\" && routeModule.Layout) {\n    return {\n      ...(Component ? {\n        element: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(Component, null))\n      } : {\n        Component\n      }),\n      ...(ErrorBoundary ? {\n        errorElement: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(ErrorBoundary, null))\n      } : {\n        ErrorBoundary\n      }),\n      ...(HydrateFallback ? {\n        hydrateFallbackElement: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(HydrateFallback, null))\n      } : {\n        HydrateFallback\n      })\n    };\n  }\n  return {\n    Component,\n    ErrorBoundary,\n    HydrateFallback\n  };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({\n  Component: () => null\n})) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let routeModule = routeModules[route.id];\n    invariant(routeModule, \"No `routeModule` available to create server routes\");\n    let dataRoute = {\n      ...getRouteComponents(route, routeModule, isSpaMode),\n      caseSensitive: route.caseSensitive,\n      id: route.id,\n      index: route.index,\n      path: route.path,\n      handle: routeModule.handle,\n      // For SPA Mode, all routes are lazy except root.  However we tell the\n      // router root is also lazy here too since we don't need a full\n      // implementation - we just need a `lazy` prop to tell the RR rendering\n      // where to stop which is always at the root route in SPA mode\n      lazy: isSpaMode ? () => spaModeLazyPromise : undefined,\n      // For partial hydration rendering, we need to indicate when the route\n      // has a loader/clientLoader, but it won't ever be called during the static\n      // render, so just give it a no-op function so we can render down to the\n      // proper fallback\n      loader: route.hasLoader || route.hasClientLoader ? () => null : undefined\n      // We don't need action/shouldRevalidate on these routes since they're\n      // for a static render\n    };\n    let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, future, isSpaMode) {\n  return createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, \"\", groupRoutesByParentId(manifest), needsRevalidation);\n}\nfunction preventInvalidServerHandlerCall(type, route, isSpaMode) {\n  if (isSpaMode) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You cannot call ${fn} in SPA Mode (routeId: \"${route.id}\")`;\n    console.error(msg);\n    throw new UNSAFE_ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n  let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n  let msg = `You are trying to call ${fn} on a route that does not have a server ` + `${type} (routeId: \"${route.id}\")`;\n  if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n    console.error(msg);\n    throw new UNSAFE_ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nfunction noActionDefinedError(type, routeId) {\n  let article = type === \"clientAction\" ? \"a\" : \"an\";\n  let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to ` + `submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n  console.error(msg);\n  throw new UNSAFE_ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let routeModule = routeModulesCache[route.id];\n\n    // Fetch data from the server either via single fetch or the standard `?_data`\n    // request.  Unwrap it when called via `serverLoader`/`serverAction` in a\n    // client handler, otherwise return the raw response for the router to unwrap\n    async function fetchServerHandlerAndMaybeUnwrap(request, unwrap, singleFetch) {\n      if (typeof singleFetch === \"function\") {\n        let result = await singleFetch();\n        return result;\n      }\n      let result = await fetchServerHandler(request, route);\n      return unwrap ? unwrapServerResponse(result) : result;\n    }\n    function fetchServerLoader(request, unwrap, singleFetch) {\n      if (!route.hasLoader) return Promise.resolve(null);\n      return fetchServerHandlerAndMaybeUnwrap(request, unwrap, singleFetch);\n    }\n    function fetchServerAction(request, unwrap, singleFetch) {\n      if (!route.hasAction) {\n        throw noActionDefinedError(\"action\", route.id);\n      }\n      return fetchServerHandlerAndMaybeUnwrap(request, unwrap, singleFetch);\n    }\n    async function prefetchStylesAndCallHandler(handler) {\n      // Only prefetch links if we exist in the routeModulesCache (critical modules\n      // and navigating back to pages previously loaded via route.lazy).  Initial\n      // execution of route.lazy (when the module is not in the cache) will handle\n      // prefetching style links via loadRouteModuleWithBlockingLinks.\n      let cachedModule = routeModulesCache[route.id];\n      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n      try {\n        return handler();\n      } finally {\n        await linkPrefetchPromise;\n      }\n    }\n    let dataRoute = {\n      id: route.id,\n      index: route.index,\n      path: route.path\n    };\n    if (routeModule) {\n      var _initialState$loaderD, _initialState$errors, _routeModule$clientLo;\n      // Use critical path modules directly\n      Object.assign(dataRoute, {\n        ...dataRoute,\n        ...getRouteComponents(route, routeModule, isSpaMode),\n        handle: routeModule.handle,\n        shouldRevalidate: needsRevalidation ? wrapShouldRevalidateForHdr(route.id, routeModule.shouldRevalidate, needsRevalidation) : routeModule.shouldRevalidate\n      });\n      let initialData = initialState === null || initialState === void 0 ? void 0 : (_initialState$loaderD = initialState.loaderData) === null || _initialState$loaderD === void 0 ? void 0 : _initialState$loaderD[route.id];\n      let initialError = initialState === null || initialState === void 0 ? void 0 : (_initialState$errors = initialState.errors) === null || _initialState$errors === void 0 ? void 0 : _initialState$errors[route.id];\n      let isHydrationRequest = needsRevalidation == null && (((_routeModule$clientLo = routeModule.clientLoader) === null || _routeModule$clientLo === void 0 ? void 0 : _routeModule$clientLo.hydrate) === true || !route.hasLoader);\n      dataRoute.loader = async ({\n        request,\n        params\n      }, singleFetch) => {\n        try {\n          let result = await prefetchStylesAndCallHandler(async () => {\n            invariant(routeModule, \"No `routeModule` available for critical-route loader\");\n            if (!routeModule.clientLoader) {\n              if (isSpaMode) return null;\n              // Call the server when no client loader exists\n              return fetchServerLoader(request, false, singleFetch);\n            }\n            return routeModule.clientLoader({\n              request,\n              params,\n              async serverLoader() {\n                preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n\n                // On the first call, resolve with the server result\n                if (isHydrationRequest) {\n                  if (initialError !== undefined) {\n                    throw initialError;\n                  }\n                  return initialData;\n                }\n\n                // Call the server loader for client-side navigations\n                return fetchServerLoader(request, true, singleFetch);\n              }\n            });\n          });\n          return result;\n        } finally {\n          // Whether or not the user calls `serverLoader`, we only let this\n          // stick around as true for one loader call\n          isHydrationRequest = false;\n        }\n      };\n\n      // Let React Router know whether to run this on hydration\n      dataRoute.loader.hydrate = shouldHydrateRouteLoader(route, routeModule, isSpaMode);\n      dataRoute.action = ({\n        request,\n        params\n      }, singleFetch) => {\n        return prefetchStylesAndCallHandler(async () => {\n          invariant(routeModule, \"No `routeModule` available for critical-route action\");\n          if (!routeModule.clientAction) {\n            if (isSpaMode) {\n              throw noActionDefinedError(\"clientAction\", route.id);\n            }\n            return fetchServerAction(request, false, singleFetch);\n          }\n          return routeModule.clientAction({\n            request,\n            params,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              return fetchServerAction(request, true, singleFetch);\n            }\n          });\n        });\n      };\n    } else {\n      // If the lazy route does not have a client loader/action we want to call\n      // the server loader/action in parallel with the module load so we add\n      // loader/action as static props on the route\n      if (!route.hasClientLoader) {\n        dataRoute.loader = ({\n          request\n        }, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) return Promise.resolve(null);\n          return fetchServerLoader(request, false, singleFetch);\n        });\n      }\n      if (!route.hasClientAction) {\n        dataRoute.action = ({\n          request\n        }, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) {\n            throw noActionDefinedError(\"clientAction\", route.id);\n          }\n          return fetchServerAction(request, false, singleFetch);\n        });\n      }\n\n      // Load all other modules via route.lazy()\n      dataRoute.lazy = async () => {\n        let mod = await loadRouteModuleWithBlockingLinks(route, routeModulesCache);\n        let lazyRoute = {\n          ...mod\n        };\n        if (mod.clientLoader) {\n          let clientLoader = mod.clientLoader;\n          lazyRoute.loader = (args, singleFetch) => clientLoader({\n            ...args,\n            async serverLoader() {\n              preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n              return fetchServerLoader(args.request, true, singleFetch);\n            }\n          });\n        }\n        if (mod.clientAction) {\n          let clientAction = mod.clientAction;\n          lazyRoute.action = (args, singleFetch) => clientAction({\n            ...args,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              return fetchServerAction(args.request, true, singleFetch);\n            }\n          });\n        }\n        if (needsRevalidation) {\n          lazyRoute.shouldRevalidate = wrapShouldRevalidateForHdr(route.id, mod.shouldRevalidate, needsRevalidation);\n        }\n        return {\n          ...(lazyRoute.loader ? {\n            loader: lazyRoute.loader\n          } : {}),\n          ...(lazyRoute.action ? {\n            action: lazyRoute.action\n          } : {}),\n          hasErrorBoundary: lazyRoute.hasErrorBoundary,\n          shouldRevalidate: lazyRoute.shouldRevalidate,\n          handle: lazyRoute.handle,\n          // No need to wrap these in layout since the root route is never\n          // loaded via route.lazy()\n          Component: lazyRoute.Component,\n          ErrorBoundary: lazyRoute.ErrorBoundary\n        };\n      };\n    }\n    let children = createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, route.id, routesByParentId, needsRevalidation);\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\n\n// When an HMR / HDR update happens we opt out of all user-defined\n// revalidation logic and force a revalidation on the first call\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n  let handledRevalidation = false;\n  return arg => {\n    if (!handledRevalidation) {\n      handledRevalidation = true;\n      return needsRevalidation.has(routeId);\n    }\n    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n  };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModule = await loadRouteModule(route, routeModules);\n  await prefetchStyleLinks(route, routeModule);\n\n  // Include all `browserSafeRouteExports` fields, except `HydrateFallback`\n  // since those aren't used on lazily loaded routes\n  return {\n    Component: getRouteModuleComponent(routeModule),\n    ErrorBoundary: routeModule.ErrorBoundary,\n    clientAction: routeModule.clientAction,\n    clientLoader: routeModule.clientLoader,\n    handle: routeModule.handle,\n    links: routeModule.links,\n    meta: routeModule.meta,\n    shouldRevalidate: routeModule.shouldRevalidate\n  };\n}\nasync function fetchServerHandler(request, route) {\n  let result = await fetchData(request, route.id);\n  if (result instanceof Error) {\n    throw result;\n  }\n  if (isRedirectResponse(result)) {\n    throw getRedirect(result);\n  }\n  if (isCatchResponse(result)) {\n    throw result;\n  }\n  if (isDeferredResponse(result) && result.body) {\n    return await parseDeferredReadableStream(result.body);\n  }\n  return result;\n}\nfunction unwrapServerResponse(result) {\n  if (isDeferredData(result)) {\n    return result.data;\n  }\n  if (isResponse(result)) {\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      return result.json();\n    } else {\n      return result.text();\n    }\n  }\n  return result;\n}\nfunction getRedirect(response) {\n  let status = parseInt(response.headers.get(\"X-Remix-Status\"), 10) || 302;\n  let url = response.headers.get(\"X-Remix-Redirect\");\n  let headers = {};\n  let revalidate = response.headers.get(\"X-Remix-Revalidate\");\n  if (revalidate) {\n    headers[\"X-Remix-Revalidate\"] = revalidate;\n  }\n  let reloadDocument = response.headers.get(\"X-Remix-Reload-Document\");\n  if (reloadDocument) {\n    headers[\"X-Remix-Reload-Document\"] = reloadDocument;\n  }\n  return redirect(url, {\n    status,\n    headers\n  });\n}\n\n// Our compiler generates the default export as `{}` when no default is provided,\n// which can lead us to trying to use that as a Component in RR and calling\n// createElement on it.  Patching here as a quick fix and hoping it's no longer\n// an issue in Vite.\nfunction getRouteModuleComponent(routeModule) {\n  if (routeModule.default == null) return undefined;\n  let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n  if (!isEmptyObject) {\n    return routeModule.default;\n  }\n}\nfunction shouldHydrateRouteLoader(route, routeModule, isSpaMode) {\n  return isSpaMode && route.id !== \"root\" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);\n}\n\nexport { createClientRoutes, createClientRoutesWithHMRRevalidationOptOut, createServerRoutes, shouldHydrateRouteLoader };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { BoundaryShell } from './errorBoundaries.js';\n\n// If the user sets `clientLoader.hydrate=true` somewhere but does not\n// provide a `HydrateFallback` at any level of the tree, then we need to at\n// least include `<Scripts>` in the SSR so we can hydrate the app and call the\n// `clientLoader` functions\nfunction RemixRootDefaultHydrateFallback() {\n  return /*#__PURE__*/React.createElement(BoundaryShell, {\n    title: \"Loading...\",\n    renderScripts: true\n  }, /*#__PURE__*/React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n              console.log(\n                \"\uD83D\uDCBF Hey developer \uD83D\uDC4B. You can provide a way better UX than this \" +\n                \"when your app is running \\`clientLoader\\` functions on hydration. \" +\n                \"Check out https://remix.run/route/hydrate-fallback for more information.\"\n              );\n            `\n    }\n  }));\n}\n\nexport { RemixRootDefaultHydrateFallback };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';\nimport * as React from 'react';\nimport { useLocation, useMatches, UNSAFE_useScrollRestoration } from 'react-router-dom';\nimport { useRemixContext } from './components.js';\n\nlet STORAGE_KEY = \"positions\";\n\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n *\n * @see https://remix.run/components/scroll-restoration\n */\nfunction ScrollRestoration({\n  getKey,\n  ...props\n}) {\n  let {\n    isSpaMode\n  } = useRemixContext();\n  let location = useLocation();\n  let matches = useMatches();\n  UNSAFE_useScrollRestoration({\n    getKey,\n    storageKey: STORAGE_KEY\n  });\n\n  // In order to support `getKey`, we need to compute a \"key\" here so we can\n  // hydrate that up so that SSR scroll restoration isn't waiting on React to\n  // hydrate. *However*, our key on the server is not the same as our key on\n  // the client!  So if the user's getKey implementation returns the SSR\n  // location key, then let's ignore it and let our inline <script> below pick\n  // up the client side history state key\n  let key = React.useMemo(() => {\n    if (!getKey) return null;\n    let userKey = getKey(location, matches);\n    return userKey !== location.key ? userKey : null;\n  },\n  // Nah, we only need this the first time for the SSR render\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n\n  // In SPA Mode, there's nothing to restore on initial render since we didn't\n  // render anything on the server\n  if (isSpaMode) {\n    return null;\n  }\n  let restoreScroll = ((STORAGE_KEY, restoreKey) => {\n    if (!window.history.state || !window.history.state.key) {\n      let key = Math.random().toString(32).slice(2);\n      window.history.replaceState({\n        key\n      }, \"\");\n    }\n    try {\n      let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || \"{}\");\n      let storedY = positions[restoreKey || window.history.state.key];\n      if (typeof storedY === \"number\") {\n        window.scrollTo(0, storedY);\n      }\n    } catch (error) {\n      console.error(error);\n      sessionStorage.removeItem(STORAGE_KEY);\n    }\n  }).toString();\n  return /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key)})`\n    }\n  }));\n}\n\nexport { ScrollRestoration };\n", "/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { createStaticRouter, StaticRouterProvider } from 'react-router-dom/server';\nimport { RemixContext } from './components.js';\nimport { RemixErrorBoundary } from './errorBoundaries.js';\nimport { createServerRoutes, shouldHydrateRouteLoader } from './routes.js';\nimport { StreamTransfer } from './single-fetch.js';\n\n/**\n * The entry point for a Remix app when it is rendered on the server (in\n * `app/entry.server.js`). This component is used to generate the HTML in the\n * response from the server.\n */\nfunction RemixServer({\n  context,\n  url,\n  abortDelay,\n  nonce\n}) {\n  if (typeof url === \"string\") {\n    url = new URL(url);\n  }\n  let {\n    manifest,\n    routeModules,\n    criticalCss,\n    serverHandoffString\n  } = context;\n  let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);\n\n  // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n  // When a route exports a `clientLoader` and a `HydrateFallback`, we want to\n  // render the fallback on the server so we clear our the `loaderData` during SSR.\n  // Is it important not to change the `context` reference here since we use it\n  // for context._deepestRenderedBoundaryId tracking\n  context.staticHandlerContext.loaderData = {\n    ...context.staticHandlerContext.loaderData\n  };\n  for (let match of context.staticHandlerContext.matches) {\n    let routeId = match.route.id;\n    let route = routeModules[routeId];\n    let manifestRoute = context.manifest.routes[routeId];\n    // Clear out the loaderData to avoid rendering the route component when the\n    // route opted into clientLoader hydration and either:\n    // * gave us a HydrateFallback\n    // * or doesn't have a server loader and we have no data to render\n    if (route && shouldHydrateRouteLoader(manifestRoute, route, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n      context.staticHandlerContext.loaderData[routeId] = undefined;\n    }\n  }\n  let router = createStaticRouter(routes, context.staticHandlerContext, {\n    future: {\n      v7_partialHydration: true,\n      v7_relativeSplatPath: context.future.v3_relativeSplatPath\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RemixContext.Provider, {\n    value: {\n      manifest,\n      routeModules,\n      criticalCss,\n      serverHandoffString,\n      future: context.future,\n      isSpaMode: context.isSpaMode,\n      serializeError: context.serializeError,\n      abortDelay,\n      renderMeta: context.renderMeta\n    }\n  }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n    location: router.state.location\n  }, /*#__PURE__*/React.createElement(StaticRouterProvider, {\n    router: router,\n    context: context.staticHandlerContext,\n    hydrate: false\n  }))), context.future.unstable_singleFetch && context.serverHandoffStream ? /*#__PURE__*/React.createElement(React.Suspense, null, /*#__PURE__*/React.createElement(StreamTransfer, {\n    context: context,\n    identifier: 0,\n    reader: context.serverHandoffStream.getReader(),\n    textDecoder: new TextDecoder(),\n    nonce: nonce\n  })) : null);\n}\n\nexport { RemixServer };\n"],
  "mappings": "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",
  "names": ["React", "router", "StaticRouterProvider", "hydrate", "json", "createStaticRouter", "ABSOLUTE_URL_REGEX", "ESCAPE_LOOKUP", "ESCAPE_REGEX", "init_dist", "json", "defer", "redirect", "redirectDocument", "React", "init_dist", "React", "init_dist", "init_dist", "value", "result", "m", "redirect", "NavLink", "Link", "router", "json", "Await", "matches", "useMatches", "useLoaderData", "useRouteLoaderData", "useActionData", "useFetcher", "LiveReload", "React", "init_dist", "React", "init_dist", "React", "Component", "fn", "msg", "result", "router", "React", "init_dist", "STORAGE_KEY", "key", "React", "router"]
}
